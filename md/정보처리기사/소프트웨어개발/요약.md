# 01 데이터 입출력 구현

- 자료 구조
  - 컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적 구조


- 자료 구조의 분류
  - 선형 구조
    - 데이터를 연속적으로 연결
    - 리스트, 스택, 큐 데크
  - 비선형 구조
    - 데이터를 비연속적으로 연결
    - 트리, 그래프



- 리스트의 종류
  - 선형 리스트(Linear List)
    - 배열과 같이 연속되는 기억 장소에 저장
    - 가장 간편한 자료구조 ,접근 구조 빠름
    - 자료의 삽입, 삭제 시 기존 자료의 이동 필요
  - 연결 리스트(Linked List)
    - 노드의 포인터 부분으로 서로 연결시킨 리스트
    - 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트 ,이중원형 연결 리스트
    - 연결을 위한 포인터가 추가되어 저장공간 추가로 필요
    - 포인터를 통해 찾는 시간 추가 선형리스트에 비해 느림



- 스택
  - 한 방향으로만 자료를 넣고 꺼낼 수 있는 LIFO(Last-In First-Out) 형식 자료구조
  - PUSH와 POP 이용
  - TOP은 스택에서 가장 위에ㅣ 있는 데이터로, 스택 포인터라고도 불림


- 스택 응용 분야
  - 인터럽트의 처리
    - 진행중인 명령어 위치 스택에 PUSH, 인터럽트 발새 상황 처리 후 인터럽트 전에 진행 중이던 명령어 위치 POP을 통해 받아옴
  - 함수 호출(재귀 호출 포함)
    - 현재 진행 중인 명령어 주소 스택에 저장
  - 후위 표현 연산
    - Postfix 계산
  - 깊이 우선 탐색(DFS; Depth-First Search)
    - 기핑 내려갈 때마다 스택에 PUSH, 더이상 깊이갈 곳이 없을 경우 스택에서 POP한 노드와 인접 노드 찾음


- 큐
  - 한쪽 끝에서는 삽입 작업이 이뤄지고, 반대쪽 끝에서는 삭제 작업이 이루어지는 FIFO(First-In First-Out) 형식 자료 구조
  - ENQUEUE 연산을 이용해 데이터 넣고 DEQUEUE 연산 이용해 데이터 꺼냄



- 데크
  - 큐의 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료구조
  - 두 개의 포인터 사용, 양쪽의 삭제/삽입 가능
  - PUSH, POP 이용


- 트리
  - 데이터들을 계층화 시킨 자료구조
  - 노드와 선분으로 되어있고 정점 사이에 사이클이 형성되어 있지 않으며 자료사이의 관계성이 계층 형식으로 나타나는 비선형 구조


- 트리 용어[루단 레 조자부형 깊차]
  - 루트 노드
    - 트리에서 부모가 없는 최상위 노드
  - 단말 노드
    - 자식이 없는 노드, 트리의 가장 말단
  - 레벨
    - 루트 노드 기준 특정 노드까지의 경로 길이
  - 조상 노드
    - 특정 노드에서 루트에 이르는 경로상 모든 노드
  - 자식 노드
    - 특정 노드에 연결된 다음 레벨 노드
  - 부모 노드
    - 특정 노드에 연결된 이전 레벨 노드
  - 형제 노드
    - 같은 부모를 가진 노드
  - 깊이
    - 루트 노드에서 특정 노드에 도달하기 위한 간선의 수
  - 차수
    - 특정 노드에 연결된 자식 노드의 수


- 트리 순회방법
  - 전위 순회
    - root -> left -> right 순
  - 중위 순회
    - left -> root -> right 순
  - 후위 순회
    - left -> right -> root


- 수식 Infix, Prefix, Postfix
  - 기호가 가운데 잇는 형태 Infix, 기호가 앞에 있는 수식 Prefix 기호가 뒤에 있는 수식 Postfix
  - a * (b + c) + d
  - 변환 순서
  - 계산 순서에 맞게 괄호
  - Prefix는 기호들을 괄호 안에서 가장 앞으로, Postfix는 괄호 안에서 가장 뒤로 옮김
  - 괄호 제거


- 트리 종류
  - 이진 탐색 트리
    - 트리 차수가 2 이하인 노드로 구성, 자식이 둘 이하로 구성된 트리
    - 부모 노드보다 작은 값은 왼쪽, 부모 노드보다 큰 값은 오른쪽 노드
  - AVL(Adelson - Velsky and Landis Tree) 트리
    - 두 자식 서브 트리의 높이는 항상 최대 1만큼만 차이가 나도록 스스로 균형을 잡음
  - 2-3 트리(2-3 Tree)
    - 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리
    - AVL 트리 단점 삽입 삭제 시 전체 트리 재구성 하는 부분 줄인 트리
  - 레드 블랙 트리(Red-Black Tree)
    - 각 노드는 빨강 또는 검정의 색상을 가지고 있으며, 색깔에 따른 규칙을 통해 스스로 균형 잡는 트리


- 그래프
  - 노드와 노드를 연결하는 간선을 하나로 모아 놓은 자료 구조


그래프 유형
- 방향 그래프
  - 정점 연결하는 선에 방향이 있는 그래프
  - n(n-1)
- 무방향 그래프
  - 정점 연결하는 선에 방향이 없는 그래프
  - n(n-1) / 2


- 그래프 용어
  - 경로
  - 경로 길이
  - 단순 경로
  - 사이클


- 그래프 탐색 방법
  - 깊이 우선 탐색(DFS; Depth-First Search)
    - 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동
  - 너비 우선 탐색(BFS; Breadth-First Search)
    - 최대한 넓게 이동한 다음, 더이상 갈 수 없을 때 아래로 이동


---

# 02 통합 구현

- 단위 모듈 구현
  - 기능을 단위 모듈별로 분할 하고 추상화하여 성능 향상, 유지보수 효과적으로 하기위 한 구현 기법
  - 인터페이스 모듈, 데이터베이스 접근 모듈 등 통합 구현에 필요한 단위 컴포넌트 구현


- 단위 모듈 구현의 원리[정분추모]
  - 정보 은닉(Information Hiding)
    - 어렵거나 변경 가능성이 있는 모듈은 타 모듈로부터 은폐
  - 분할과 정복(Divide & Conquer)
    - 복잡한 문제 분해, 모듈 단위로 문제 해결
  - 데이터 추상화(Data Abstraction)
    - 각 모듈 자료 구조를 액세스하고 수정하는 함수내에 자료 구조의 표현 내역을 은폐
  - 모듈 독립성(Module Independence)
    - 낮은 결합도와 높은 응집도


- 구현 단계에서 작업 절차
  - 코딩 계획
    - 수행 방법 논리적으로 결정
  - 코딩
    - 논리적으로 결정한 문제 특정 프로그래밍 언어로 구현
    - 언어 선택 시 개발 정보시스템의 특성, 사용자의 요구사항, 컴파일러의 가용성 고려
  - 컴파일
    - 작성한 코드 다른 언어의 코드로 변환
  - 테스트
    - 기능이 요구사항을 만족하는지 검사하고 평가
    
    
- 재사용 기법
  - 이미 개발되어 기능, 성능 및 품질을 인정 받았던 소프트웨어의 전체 또는 일부분을 다시 사용


- 재사용 종류
  - 재공학(Re-Engineering)
    - 기존 소프트웨어 버리지 않고 기능 개선, 새로운 소프트웨어로 재활용
    - 장점 : 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세의 오류 억제
      - 분석(Analysis)
        - 기존 소프트웨어 명세 확인, 동작 이해, 재공학 대상 선정
      - 재구조(Restructuring)
        - 상대적으로 같은 추상적 수준에서 하나의 표현ㅇ르 다른 형태로 바꾸는 작업
      - 역공학(Reverse Engineering)
        - 기존 소프트웨어 분석해 설계도 추출
      - 이식(Migration)
        - 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환
  - 재개발(Re-Development)
    - 기존 시스템 내용 참조하여 완전히 새로운 시스템 개발


- 재사용 규모에 따른 분류
  - 함수와 객체 : 클래스나 메서드 단위 소스 코드
  - 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스 통해 통신하는 방식 재사용
  - 애플리케이션 : 기능 제공하는 애플리케이션 공유하는 방식으로 재사용



- 단위 모듈 테스트
  - 모듈의 개별적인 코드 단위가 예상대로 작동하는지 확인
  - IDE 도구 활용, 개별 단위 모듈에 대한 디버깅 수행


- 테스트와 디버그 차이
  - 테스트
    - 시스템이 정해진 요구를 만족하는지, 예상과 실제 결과가 어떤 차이를 보이는지 검사하고 평가
    - 오류를 찾는 작업
  - 디버그
    - 개발 중 발생하는 시스템의 논리적인 오류나 버그를 찾아서 수행하는 과정
    - 오류를 수정하는 작업


- 단위 모듈 테스트의 종류
  - 블랙박스 테스트(=명세 기반 테스트)
    - 사용자의 요구사항 명세를 보면서 수행(기능 테스트)
    - 요구사항, 설계 명세서 등에 초점
  - 화이트박스 테스트(=구조 기반 테스트)
    - 모듈 내부의 소스를 보면서 수행
    - 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트


- 협업 도구의 기능
  - 개발자 간 커뮤니케이션
  - 일정 및 이슈 공유
  - 개발자 간 집단 지성 활용


- 형상 관리
  - 소프트웨어 생명주기 동안 발생하는 변경사항을 체계적으로 관리하여 소프트웨어의 품질 보증을 향상시키는 관리적 활동
  - 개발 과정의 변경 사항을 관리
  - 관리 항목
    - 프로젝트 요구 분석서
    - 소스 코드
    - 운영 및 설치 지침서
  - 유지보수 단계뿐만 아니라 개발 단계에도 사용


- 형상 관리 절차[식통감기]
  - 형상 식별
    - 형상 관리 대상이 무엇인지
  - 형상 통제
    - 형상 항목의 버전 관리
    - 변경사항에 대해 형상통제위원회가 승인/기각/보류 결정
  - 형상 감사
    - 형상 관리 계획대로 형상 관리가 진행되고 있는지, 요구사항에 맞도록 제대로 이뤄졌는지 등 살펴보는 활동
  - 형상 기록
    - 형상 및 변경 관리에 대한 각종 수행결과 기록
    - 형상결과 보고서 작성



- 형상 관리 도구의 기능[인아커]
  - 체크인 : 수정한 소스 형상 관리 저장소로 업롣
  - 체크아웃 : 형상 관리 저장소로부터 최신 버전 다운로드
  - 커밋 : 형상 관리 저장소에 업로드 후 최종적으로 업데이트 되었을 때 형상 관리 서버에서 반영



- 형상 관리 도구 사례[CSG]
  - CVS(Concurrent Versions System)
    - 중앙 집중형 서버 저장소
    - 파일 단위로 변경사항 관리 가능
  - SVN(Subversion)
    - 중앙 집중형 클라이언트-서버 방식
  - Git
    - 로컬 / 원격 형상관리
    - 이관 기능

---

# 03 제품 소프트웨어 패키징

- 애플리케이션 패키징 특징
  - 사용자 중심으로 진행
  - 신규 및 변경 개발 소스 식별
  - 이를 모듈화하여 상용 제품으로 패키징
  - 신규 / 변경 이력 확인
  - 버전 관리 및 릴리즈 노트를 통해 지속적 관리
  - 사용자 실행 환경을 이해하고, 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 분류하여 패키징


- 사용자 관점에서의 패키징 고려사항[환유관변]
  - 사용자 시스템 환경 정의
    - 운영체제, CPU, 메모리
  - UI 제공
    - 직관적으로 확인할 수 있는 UI 제공, 메뉴얼과 일치시켜 패키징
  - 관리 서비스 형태로 제공
    - 하드웨어와 함께 통합 적용할 수 있도록 관리서비스 형태로 제공
  - 패키징의 변경 및 개선 관리 고려
    - 다양한 요구사항 반영을 위해 변경 및 개선 관리 고려 패키징



- 애플리케이션 패키징 프로세스[기모빌 사적변]
  - 기능 식별
  - 모듈화
  - 빌드 진행
  - 사용자 환경 분석
  - 패키징 적용 시험
  - 패키징 변경 개선


- 애플리케이션 배포 도구
  - 패키징 시 디지털 컨텐츠의 지적 재산권을 보호하고 관리하는 기능 제공
  - 안전한 유통과 배포 보장


- 애플리케이션 배포 도구의 기술요소[암키식저 파정크인]
  - 암호화
    - 콘텐츠 및 라이선스 암호화, 전자서명
  - 키 관리
    - 암호화한 키에 대한 저장 및 배포
  - 식별 기술
    - 콘텐츠에 대한 식별 체계 표현 기술
  - 저작권 표현
    - 라이선스의 내용 표현 기술
  - 암호화 파일
    - 암호화된 컨텐츠로 생성
  - 정책 관리
    - 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
  - 크랙 방지
    - 크랙에 의한 콘텐츠 사용 방지
  - 인증
    - 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술


- 애플리케이션 배포 도구 세부 기술
  - 공개키 기반 구조
  - 대칭 및 비대칭 암호화
  - 전자서명
  - DOI(Digital Object Identifier)
  - URL(Uniform Resource Identifier)
  - XrML(eXtensible Right Markup Language)
  - MPEG-21
  - XML(eXtensible Markup Language)
  - CMS(Contents Management System)
  - 코드 난독화
    - 역공학 통한 공격 막기 위한 기술
  - Secure DB
    - 커널 암호화 형식으로 데이터베이스 파일 직접암호화
  - SSO(Single Sign On)


- 애플리케이션 배포 도구를 활용한 배포 프로세스
  - 빌드 내용 식별
  - 패키징 도구 식별
  - DRM 흐름을 확인하여 패키징 수행
  - 패키징 도구 설치
  - 배포 작업
  - 정상 배포 확인



- 애플리케이션 배포 도구 활용 시 고려사항[암이복최]
  - 암호화/보안
    - 사용자에게 배포되는 소프트웨어임을 감안
    - 내부 컨텐츠에 대한 암호화 및 보안 고려
  - 이기종 연동
    - 여러 이기종 컨텐츠 및 단말기 간 DRM 연동 고려
  - 복잡성 및 비효율성 문제
    - 사용자 입장에서 불편해질 수 있는 문제 고려, 최대한  효율적으로 적용
  - 최적합 암호화 알고리즘
    - 소프트웨어의 종류에 맞는 알고리즘 선택, 배포 시 범용성에 지장 없도록 고려

    
- 애플리케이션 모니터링 도구
  - 제품 소프트웨어를 사용자 환경에 설치한 후 기능 및 성능, 운영 현황을 모니터링하여 제품 최적화


- 애플리케이션 모니터링 도구의 기능
  - 애플리케이션 변경 관리
    - 종속관계 모니터링
    - 변경의 영향도 파악
    - 도구 : ChangeMiner
  - 애플리케이션 성능 관리
    - 서버로 유입되는 트랜잭션 수량, 처리시간, 응답 시간 등 모니터링
    - 도구 : Jenifer, Nmon
  - 애플리케이션 정적 분석
    - 소스 코드의 잠재적인 문제 발견 가능
    - 코딩 규칙 오류 발견
    - 도구 : PMD, Cppcheck, Checkstyle, SonarQube
  - 애플리케이션 동적 분석
    - 결함 및 취약점 동적 분석 도구
    - 메모리 및 오류 발견
    - 도구 : Avalanche, Valgrind


- 애플리케이션 모니터링 도구 활용에 따른 효과
  - 서비스 가용성
  - 서비스 성능
  - 장애 인지/리소스 측정
  - 근본 원인 분석



- DRM(Digital Rights Management)
  - 디지털 컨텐츠에 대한 권리정보를 지정하고 암호화 기술을 이용하여 허가된 사용자의 허가된 권한 범위 내에서 컨텐츠의 이용이 가능하도록 통제


- DRM 특징
  - 거래 투명성
  - 사용규칙 제공
  - 자유로운 상거래 제공

- DRM 동작 방식
  - 라이선스 등록
  - 라이선스 요청
    - 콘텐츠 소비자가 유통시스템으로 라이선스 요청
  - 라이선스 요청
    - 유통시스템에서 클리어링 하우스를 통해 라이선스 요청
  - 요금 지불
  - 랄이선스 발급
  - 콘텐츠 다운로드


- DRM 구성요소[제소분 클콘패 컨보]
  - 콘텐츠 제공자(Contents Provider)
  - 콘텐츠 소비자(Contents Customer)
  - 콘텐츠 분배자(Contents Distributor)
    - 암호화된 컨텐츠를 유통하는 곳이나 사람
  - 클리어링 하우스(Clearing House)
    - 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 관리 등 수행
    - 키 관리 및 라이선스 발급 관리
    - 컨텐츠 권한 정책
      - 적절한 사용 권한 부여
    - 컨텐츠 라이선스
      - 컨텐츠에 대한 사용 조건 및 서가 정보 포함
  - DRM 콘텐츠(DRM Contents)
    - 서비스하고자 하는 암호화된 컨텐츠, 컨텐츠와 관련된 메타데이터(자료의 속성 등을 설명), 컨텐츠 사용정보를 패키징하여 구성된 컨텐츠
  - 패키저(Packager)
    - 컨텐츠를 메타 데이터와 함께 배포 가능한 단위를 묶는 도구
  - DRM 컨트롤러(DRM Controller)
    - 배포되 디지털 컨텐츠 이용 권한 통제
  - 보안 컨테이너(Security Container)
    - 원본 컨텐츠를 안전하게 유통하기 위한 전자적 보안장치


- DRM의 기술요소[암키식저 파정크인]
  - 암호화
  - 키 관리
  - 식별 기술
  - 저작권 표현
  - 암호화 파일 생성
  - 정책 관리
  - 크랙 방지
  - 인증


- 제품 소프트 웨어 매뉴얼
  - 제품 소프트웨어 개발 단계부터 적용한 기준이나 패키징 이후 설치 및 사용자 측면의 주요 내용 등을 문서로 기록한 것
  - 사용자 중심의 기능 및 방법을 나타낸 설명서와 안내서


- 제품 소프트웨어 설치 매뉴얼
  - 제품 구매 후 최초 설치 시 참조하는 매뉴얼
  - 설치 과정 중 예외상황에 관련 애용 별도 구분 설명
  - 시작 부터 완료까지 전 과정 빠짐없이 순서대로 설명


- 제품 소프트웨어 설치 매뉴얼 기본 작성 항목
  - 목차 및 개요
  - 문서 이력 정보
  - 설치 매뉴얼 주석
  - 설치 도구의 구성
  - 설치 위치 지정

- 제품 소프트웨어 설치 환경 체크 항목
  - 사용자 환경
  - 응용 프로그램
  - 업그레이드 버전
  - 백업 폴더 확인


- 제품 소프트웨어 설치 매뉴얼 구성요소[개파절아 삭버고준]
  - 제품 소프트웨어 개요
  - 설치 관련 파일
  - 설치 절차
  - 설치 아이콘
  - 삭제 방법
  - 설치 버전 및 작성자
  - 고객 지원 방법 및 FAQ
  - 준수 정보 & 제한 보증


- 제품 소프트웨어 사용자 매뉴얼 작성 항목
  - 목차 및 개요
  - 문서 이력 정보
  - 사용자 매뉴얼 주석
  - 기록 항목
  - 기본 사항
  - 고객 지원 방법 및 FAQ
  - 준수 정보 & 제한 보증


- 제품 소프트웨어 사용자 매뉴얼 작성 프로세스
  - 작성 지침 정의
  - 사용자 매뉴얼 구성요소 정의
  - 구성요소별 내용 작성
  - 사용자 매뉴얼 검토


- 국제 표준 제품 품질 특성
  - 제품에 대하여 명확하게 정의된 특성을 의미
  - 품질을 평가하는 기준 항목
  - 품질에 관련된 국제 표준화는 ISO/IEC, ITU-T, IEEE를 중심으로 진행


- 국제 제품 품질 표준
  - ISO/IEC 9126
    - 품질 측정 평가 
    - 소프트웨어 품질을 측정하고, 평가하기 위해서 소프트웨어의 품질요소소와 특성을 정의
    - 품질 특성은 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성으로 나눔
  - ISO/IEC 14598
    - 소프트웨어 제품 평가 프로세스 및 평가 모듈을 제공
    - 개발 과정 또는 개발이 완료된 제품의 품질에 대한 평가 표준
    - 품질 측정 절차 별도 표준
  - ISO/IEC 12119
    - 품질 요구사항 및 테스트 국제 표준
    - 대상 : 제품 설명서, 사용자 문서, 실행 프로그램
  - ISO/IEC 25000
    - SQuaRE로도 불림
    - ISO/IEC 9126과 ISO/IEC 14598, ISO/IEC 12119를 통합하고, ISO/IEC 15288을 참고한 제품 품질에 대한 통합적인 국제표준
    - 개발 공정 각 단계에서 산출되는 제품이 요구사항을 만족하는지 검증


- ISO/IEC 9126의 소프트웨어 품질 특성[기신사 효유이]
  - 기눙성(Functionality)
    - 명시된 요구와 내재된 요구 만족
    - 적합성, 정확성, 상호운용성, 보안성, 준수성
  - 신뢰성(Reliability)
    - 성능 수준 유지
    - 옳고 일관된 결과를 얻기 위해 요구된 기능 수행 할 수 있는 정도
    - 기능을 오류 없이 수행
    - 성숙성, 결함 허용성, 회복성, 준수성
  - 사용성(Usability)
    - 사용자에 의해 이해되고, 학습되고, 사용되고, 선호될 수 있는 능력
    - 이해성, 학습성, 운용성, 친밀성, 준수성
  - 효율성(Efficiency)
    - 사용되는 자원의 양에 따라 요구된 성능 제공
    - 시간 반응성, 자원 효율성, 준수성
  - 유지보수성(Maintainability)
    - 제품 변경되는 능력
    - 명세에 따른 소프트웨어의 수정, 개선, 개작 등 포함
    - 분석성, 변경성, 안정성, 시험성, 준수성
  - 이식성(Portability)
    - 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 능력
    - 적응성, 설치성, 공존성, 대체성, 준수성 등


- ISO/IEC 14598의 소프트웨어 품질 특성[반재공객]
  - 반복성(Repeatability)
    - 동일 평가자, 동일 사양 평가, 동일 결과
  - 재현성(Reproducibility)
    - 다른 평가자, 동일 사양 평가, 유사한 결과
  - 공정성(Impartiality)
    - 평가가 특정 결과에 편향되지 않아야 함
  - 객관성(Objectivity)
    - 평가 결과는 객관적 자료에 의해서만 평가되어야 함
- 개발자 관점에서 고려해야할 항목 - 정확성, 신뢰성, 효율성, 무결성, 유연성, 이식성, 사용성, 상호운용성


- 국제 프로세스 품질 표준
  - ISO/IEC 9001
    - 설계/개발, 생산, 설치 및 서비스 과정에 대한 품질
  - ISO/IEC 12207
    - 소프트웨어의 획득, 공급, 개발, 운영, 유지보수를 체계적으로 관리하기 위한
    - 소프트웨어 생명주기 단계별 필요 프로세스 규정
  - ISO/IEC 15504(SPICE)
    - 소프트웨어 품질 및 생산성 높이고자 함
    - ISO/IEC 12207에 준거
    - 기본/지원/조직 프로세스로 구분
  - CMMI
    - 기존 CMM 모델 통합, ISO15504(SPICe)를 준수
    - 개발 능력/성숙도 평가 및 프로세스 개선 활동의 지속적인 품질 개선 모델



- 소프트웨어 품질 평가 통합 모델 ISO/IEC 25000
  - SQuaRE(System and Software Quality Requirements and Evaluation)


- ISO/IEC 25000 구성요소[관모측요평]
  - 2500n 품질 관리
    - SQuaRE 표준의 가이드라인과 품질 평가의 관리에 관한 표준 제시
    - ISO 14598-2 기반
  - 2501n 품질 모델
    - 제품 품질 평가의 일반모델 제시
    - 구 표준에는 없는 데이터 품질 모델 제정
    - ISO 9126-1 기반
  - 2502n 품질 측정
    - 품질 측정 메트릭 정의
    - 소프트웨어의 내부 측정, 외부 측정, 사용품질 측정, 품질 측정요소 등 다룸
    - ISO 9126-2, 3, 4 기반
  - 2503n 품질 요구
    - 품질 요구사항 설정 프로세스
    - ISO 15288 기반
  - 2504n 품질 평가
    - 품질평가 절차를 정의
    - ISO 14598 기반


- 소프트웨어 위기
  - 비용이 초과 되거나, 일정이 지연되거나, 요구사항을 만족시키지 못하는 등의 현상으로 나타남


- 소프트웨어 공학(Software Engineering)
  - 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법
  - 신뢰성 있는 소프트웨어를 경제적인 비용으로 획득하기 위해 공학적 원리를 정립하고 이를 이용
  - 소프트웨어 위기를 극복하기 위한 방안으로 연구된 학문

- 소프트웨어 공학의 원칙
  - 현대적인 프로그램이 기술을 계속적으로 적용
  - 개발된 소프트웨어의 품질이 유지되도록 지속적 검증 수행
  - 개발 관련 사항 및 결과에 대한 명확한 기록 유지

- 공학적으로 잘된 소프트웨어
  - 유지보수 용이
  - 신뢰성 높아야 함
  - 충분한 테스팅


- 소프트웨어 공학 관련 법칙
  - 브룩스의 법칙(Brooks' Law)
    - 지체되는 소프트웨어 개발 프로젝트에 인력을 추가하는 것은 개발을 늦출 뿐이다
  - 파레토 법칙(80 대 20)
    - 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상
  - 롱테일 법칙
    - 사소해 보이는 80%의 다수가 20%의 소수 핵심보다도 뛰어난 가치를 창출


- 소프트웨어 버전 관리 도구
  - 형상 관리 지침을 활용하여 제품 소프트웨어의 신규 개발, 변경, 개선과 관련된 수정 사항을 관리하는 도구

- 소프트웨어 버전 관리 도구 유형[공클분]
  - 공유 폴더 방식
    - 개발 완료 파일 약속된 위치에 공유
    - RCS
  - 클라이언트 / 서버 방식
    - 버전 관리 자료 중앙 시스템에 저장되어 관리
    - CVS, SVN
  - 분산 저장소 방식
    - 로컬 저장소와 원격 저장소로 분리되어 관리되는 방식
    - Git


- 소프트웨어 버전 관리 도구별 특징
  - RCS(Revision Control System)
    - 소스 파일의 수정을 한 사람만으로 제한
    - 파일 동시 주정 제한
    - 파일 잠금 방식
    - 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적
  - CVS(Concurrent Versions System)
    - 가장 오래된 형상 관리 도구
    - 중앙 집중형 서버
  - SVN(Subversion)
    - 중앙 집중형 클라이언트-서버
  - Git
    - 분산형 방식
    - 로컬, 원격 저장소


- 소프트웨어 버전 관리 도구 사용 시 유의사항
  - 버전에 대한 쉬운 정보 접근성
  - 불필요한 사용자에 대한 접근 제어
  - 동일 프로젝트에 대한 동시 사용성
  - 빠른 오류 복구



- 빌드 자동화 도구
  - 제품 소프트웨어 실행파일 생성을 자동화하기 위해 저장소에 있는 소스를 자동으로 읽어 빌드 후 테스트하고 검사하여 실행파일 만드는 도구


- 빌드 자동화 프로세스
  - 컴파일
  - 패키징
  - 단위테스트
  - 정적분석
  - 리포팅
  - 배포
  - 최종빌드

- 빌드 자동화 구성요소[CS 빌테커인]
  - CI(Continuous Integration)서버
    - 빌드 프로세스 관리 서버
    - Jenkins
    - Hudson
  - CSM(Source Code Management)
    - 소스 코드 형상 관리 시스템
    - SVN, Git
  - 빌드 도구(Build Tool)
    - 컴파일, 테스트, 정적분석 등을 통해 동작 가능한 소프트웨어 생성
    - Ant, Maven
  - 테스트 도구(Test Tool)
    - 작성된 테스트 코드에 따라 자동으로 테스트를 수행해주는 도구
    - Junit, Selenium
  - 테스트 커버리지 도구(Test Coverage Tool)
    - 테스트 코드가 대상 소스 코드에 대해 어느 정도 커버하는지 분석
    - Emma
  - 인스펙션 도구(Inspection Tool)
    - 프로그램 실행하지 않고, 소스 코드 자체로 품질 판단 정적 분석 도구
    - 코딩 표준 준수 검사, 코드 메트릭 측정, 중복 코드 검사, 코드 인스펙션 검사
    - CheckStyle, Cppcheck


- 젠킨스
  - 자바 기반의 오픈소스, 빌드 자동화 도구
  - 지속적 통합관리 가능


- 그래들
  - 그루비와 유사한 도메인 언어 채용
  - 안드로이드 스튜디오의 공식 빌드 자동화 시스템
  - 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
  - 여러 가지 언어 지원


- 테스트 케이스
  - 특정 요구사항에 준수하는 지를 확인하기 위해 개발된 입력값, 실행조건, 예상된 결과의 집합


- 테스트 케이스 작성 절차
  - 테스트 계쇡 검토 및 자료 확보
  - 위험 평가 및 우선순위 결정
  - 테스트 요구사항 정의
  - 테스트 구조 설계 및 테스트 방법 결정
  - 테스트 케이스 정의 및 작성
  - 테스트 케이스 타당성 확인 및 유지보수


- 테스트 케이스 구성요소(ISO/IEC/IEEE 29119-3 표준)
  - 식별자
    - 테스트 케이스 고유 식별
  - 테스트 항목
    - 테스트 할 모듈 또는 기능
  - 입력명세
    - 테스트 실행 시 입력 데이터
  - 출력명세
    - 테스트 케이스 실행 시 기대되는 결과
  - 환경설정
    - 테스트 수행시 필요한 환경, 물리적, 논리적 테스트 환경
  - 특수절차요구
    - 특별히 요구되는 절차
  - 의존성 기술
    - 테스트 케이스 간 의존성 및 종속성



- 테스트 오라클
  - 테스트의 결과가 참인지 거짓인지를 판단하기 위해 사전에 정의된 참값을 입력하여 비교


- 테스트 오라클 종류[참샘휴일]
  - 참(True)
    - 모든 입력값에 대하여 기대하는 결과 생성
  - 샘플링(Sampling)
    - 특정한 몇개의 입력값에 대해서만 기대하는 결과
  - 휴리스틱(Heuristic)
    - 샘플링 오라클을 개선, 특정 입력값에 대해 올바른 결과 제공
    - 나머지 값들에 대해서는 휴리스틱(추정)으로 처리
  - 일관성 검사(Consistent)
    - 변경이 있을 때 수행전과 후의 결괏값이 동일한지 확인


- 테스트 레벨 종류[단통시인]
  - 단위 테스트
    - 모듈, 서브루틴 테스트
    - 인터페이스 테스트
    - 자료 구조 테스트
    - 실행 경로 테스트
    - 오류 처리 테스트
    - 명세 기반 테스트(=블랙박스 테스트)
    - 구조 기반 테스트(=화이트박스 테스트)
  - 통합 테스트
    - 단위 테스트 통과한 컴포넌트 간 인터페이스 테스트
    - 빅뱅 테스트
    - 상향식 / 하향식 테스트
  - 시스템 테스트
    - 시스템 또는 제품의 동작에 대해 테스트
    - 기능 요구사항 테스트
      - 요구사항 명세서, 비즈니스 절차, 유스케잇스 등 명세서 기반 블랙박스 테스트
    - 비기능 요구사항 테스트
      - 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스테므이 메뉴구조 등 구조적 요소에 대한 화이트 박스 테스트
  - 인수 테스트
    - 계약상 요구사항 만족되었는지 확인
    - 알파 / 베타 테스트

- 소프트웨어 생명주기의 V 모델
  - 소프트웨어 개발 단계를 연결하여 표현한 것 



- 테스트 시나리오
  - 테스트되어야 할 기능 및 특징, 테스트가 필요한 상황 작성 
  - 수행 절차 미리 정함으로써 설계 단계에서 중요시 되던 요구사항이나 대안 흐름과 가튼 테스트 항목 빠짐없이 테스트


- 테스트 시나리오 작성 시 유의점
  - 테스트 시나리오 분리 작성
  - 고객의 요구사항과 설계 문서 토대로 작성
  - 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등 항목 포함 작성


- 프로그램 실행 여부에 따른 테스트 분류
  - 정적 테스트
    - 구조 분석 논리성 검증
    - 리뷰(동료 검토, 워크 스루, 인스펙션)
  - 동적 테스트
    - 소프트웨어 실행하는 방식 테스트
    - 화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트



- 블랙박스 테스트
  - 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트
  - 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점
  - 기능 및 동작 위주의 테스트 진행하기 때문에 내부 구조나 작동 원리를 알지 못해도 가능
  - 명세 테스트라고 부름



- 블랙박스 테스트 유형[동경결상 유분페원비오]
  - 동등 분할 테스트(Equivalence Partitioning Testing)
    - 유사한 도메인 별 유효값/무효값 그룹핑 대표값으로 테스트
  - 경곗값 분석 테스트(Boundary Value Analysis Testing)
    - 등가분할 후 경계값 포함 테스트
    - 최솟값 바루 위 최댓값 바로 아래
  - 결정 테이블 테스트(Decision Table Testing)
    - 요구사항 논리, 발생조건 테이블 형태로 나열, 조건 행위 모두 조합
  - 상태전이 테스트(State Transition Testing)
    - 객체 상태 구분, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수
  - 유스케이스 테스트(Usecase Testing)
    - 유스케이스로 모델링 되어 있을 때 프로세스 흐름 기반으로 테스트
  - 분류 트리 테스트(Classification Tree Method Testing)
    - SW 트리구조로 분석 및 표현 테스트
  - 페어와이즈 테스트(Pairwise Testing)
    - 테스트 데이터 간 최소한 한 번씩 조합
  - 원인-결과 그래프 테스트(Cause-Effect Graph Testing)
    - 입력 데이터 간 관계 및 출력에 미치는 영향 분석
  - 비교 테스트(Comparison Testing)
    - 같은 입력 값 넣어 동일한 결과 나오는지 비교
  - 오류 추정 테스트(Error Guessing Testing)
    - 실수 추정, 이에 따른 결함 검출되도록 테스트 케이스 설계
    - 경험 직관 바탕 개발자가 범할 수 있는 실수 나열
    - 다른 블랙 박스 테스트 기법 보완


- 화이트박스 테스트
  - 각 응용 프로그램의 내부 구조와 동작을 검사
  - 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부 직접 관찰하고 테스트
  - 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행
  - 산출물 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분 수행
  - 논리적 경로 점검
  - 구조 기반테스트, 코드 기반 테스트, 로직 기븐 테스트, 글래스 박스 테스트라고 부름

  
- 화이트박스 테스트 유형[구결조 조변다 기제데루]
  - 구문 커버리지 = 문장커버리지(Statement Coverage)
    - 프로그램 내 모든 명령문 적어도 한 번 수행
    - 조건문 결과와 관계없이 구문 실행 개수로 계산
  - 결정 커버리지 = 선택 커버리지(Decision Coverage) = 분기 커버리지(Branch Coverage)
    - 결정 포인트 내 전체 조건식이 한 번은 참과 거짓 결과 수행
  - 조건 커버리지(Condition Coverage)
    - 결정 포인트 내 각 개별 조건식이 한 번은 참과 거짓 수행
  - 조건-결정 커버리지(Condition/Decision Coverage)
    - 전체 조건식 뿐 아니라 개별 조건식도 참, 거짓 한 번 결과 되도록 수행
  - 변경 조건-결정 커버리지(Modified Condition / Decision Coverage)
    - 개별조건식이 다른 개별조건식에 영향 받지 않고, 전체 조건식에 독립적으로 영향
    - 조건/결정 커버리지 향상
  - 다중 조건 커버리지(Multiple Condition Coverage)
    - 결정 조건 내 모든 개별 조건식 모든 가능한 조합 100% 보장
  - 기본 경로 커버리지 = 경로 커버리지(Base Path Coverage)
    - 수행 가능한 모든 경로 테스트
    - 기본 경로는 사이클 허용
  - 제어 흐름 테스트(Control Flow Testing)
    - 제어구조 그래프 형태로 나타내 내부 로직 테스트
  - 데이터 흐름 테스트(Data Flow Testing)
    - 데이터 사용현황을 추가한 그래프를 통해 테스트
  - 루프 테스트(Loov Testing)
    - 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시


- 테스트 시각에 따른 분류
  - 검증(Verification)
    - 소프트웨어 개발 과정 테스트
  - 확인(Validation)
    - 소프트웨어 결과 테스트


- 테스트 목적에 따른 분류[회안성 강 구회병]
  - 회복 테스트(Recovery Test)
    - 고의 실패 유도, 정상적 복귀 여부 테스트
  - 안전 테스트(Security Test)
    - 소스 코드 내 보안적 결함 미리 점검
  - 성능 테스트(Performance Test)
    - 시스템 응답 시간, 특정 시간 내 처리 업무량, 시스템 반응 속도 등 측정
  - 강도 테스트(Stress Test)
    - 부하 임계점 이상의 부하 가하여 비정상적 상황 처리 테스트
  - 구조 테스트(Structure Test)
    - 내부 논리경로, 소스 코드 복잡도 평가
  - 회귀 테스트(Regression Test)
    - 오류 제거, 수정에 의해 새로이 유입된 오류 없는지 확인
  - 병행 테스트(Parallel Test)
    - 변경된 시스템, 기존 시스템 동일한 데이터 입력 후 결과 비교



- 소프트웨어 테스트의 원리[결완초집살정오]
  - 결함 존재 증명
  - 완벽 테스팅은 불가능
  - 초기 집중
  - 결함 집중
  - 살충제 패러독스
    - 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못한다는 원리
  - 정황 의존성
  - 오류-부재의 궤변


- 결함 관리 도구
  - 단계별 테스트 수행 후 발생한 결함의 재발 방지
  - 유사 결함 발견 시 처리 시간 단축 결함 추적 관리



- 결함(Defect)의 개념
  - 개발자 오류로 인해 만들어지는 문서 또는 코딩 상의 결점


- 소프트웨어 결함 관련 용어
  - 오류
    - 결함의 원인이 되는 것
  - 결점
    - 소프트웨어 개발 활동 수행하멩 있어 시스템이 고장을 일으키게 하며
  - 버그
    - 예상치 못한 결과
  - 고장/문제
    - 결함이 실행될 때 발생


- 테스트 자동화 도구
  - 반복적인 테스트 작업을 스크립트 형태로 구현
  - 테스트 시간 단축, 인력 투입 비용 최소화



- 정적 분석 도구
  - 만들어진 애플리케이션을 실행하지 않고 분석하는 방법
  - 소스코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 발견
  - 작성된 소스코드에 대한 이해를 바탕으로 도구를 이용해 분석
  - 자료흐름이나 논리 흐름을 분석하여 비정상적 패턴 찾을 수 있음


- 정적 분석 테스트 자동화 도구
  - PMD, Checkstyle, Splint, Cppcheck, SonarQube

- 성능 테스트 도구
  - 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트 수행

- 성능 테스트 자도화 도구
  - Cobertura, Clover


- 테스트 장치 구성요소[드스슈 케시스목]
  - 테스트 드라이버(Test Driver)
    - 상향식 통합 테스트를 위한 시험용 모듈
    - 하위 모듈을 호출하는 상위 모듈 역할
  - 테스트 스텁(Test Stub)
    - 하향식 통합 테스트를 위한 시험용 모듈
    - 상위 모듈에 의해 호출되는 하위 모듈 역할
  - 테스트 슈트(Test Suite)
    - 테스트 케이스 집합
    - 시나리오가 포함되지 않은 단순 테스트 케이스 모임
  - 테스트 케이스(Test Case)
    - 입력값, 실행조건, 기대 결과 등의 집합
  - 테스트 시나리오(Test Scenario)
    - 테스트 되어야 할 기능 및 특징, 테스트 필요한 상황 작성
    - 하나의 단일 시나리오, 하나 또는 여러개 테스트 케이스 포함
  - 테스트 스크립트(Test Script)
    - 테스트 케이스 실행 순서 작성 문서
  - 목 오브젝트(Mock Object)
    - 사전자 행위 조건부로 사전에 입력
    - 상황에 예정된 행위 수행


- 테스트 케이스 자동 생성 도구를 통한 테스트 데이터 도출 방법
  - 자료 흐름도
  - 기능 테스트
  - 입력 도메인 분석
  - 랜덤 테스트


- 하향식 및 상향식 통합 수행 방식[하스 상드]
  - 하향식 스텁
  - 상향식 드라이버

- 하향식 통합 테스트(Top Down Integration Test)
  - 메인 제어모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하는 테스트
  - 깊이-우선, 너비-우선 방식
  - 위에서 아래로 내려오기 때문에 검사 초기에 시스템의 구조가 파악되어야 함


- 상향식 통합 테스트(Bottom Up Integration Test)
  - 최하위 레벨 모듈, 컴포넌트로부터 점진적으로 상위 모듈과 함께 테스트


- 알고리즘 기법[분동탐백]
  - 분할과 정복(Divide and Conquer)
    - 나눌 수 없을 때까지 나누고 각각을 풀면서 다시 병합
  - 동적계획법(Dynamic Programming)
    - 과거에 구한 해를 활용하는 방식
  - 탐욕법(Greedy)
    - 결정 해야 할 때 그 순간 가장 좋다고 생각되는 것 선택
  - 백트래킹(Backtracking)
    - 유망성 점검 후 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손노드 검색



- 시간 복잡도에 따른 알고리즘 분류
  - O(1)
    - 상수형 복잡도
    - 자료크기 무관하게 항상 같은 속도로 작동
    - 알고리즘 수행시간 입력 데이터 수와 관계없이 일정
    - 해시 함수(Hash Function)
  - O(log2n)
    - 로그형 복잡도
    - 문제 해결 단계수 log2n 만큼 수행 시간
    - 이진 탐색(Binary Search)
  - O(n)
    - 선형 복잡도
    - 입력 자료를 차례로 하나씩 모두 처리
    - 수행 시간이 자료 크기와 직접적 관계(정비례)
    - 순차 탐색(Sequential Search)
  - O(nlog2n)
    - 선형 로그형 복잡도
    - 문제 해결 단계수 nlog2n번만큼 수행시간 가짐
    - 퀵 정렬, 합병 정렬, 힙 정렬
  - O(n2제곱)
    - 제곱형 복잡도
    - 주요 처리 루프 구조가 2중인 경우의 복잡도
    - n의 크기가 작을 때에는 n제곱이 nlo2n보다 빠를 수 있음
    - 거품 정렬, 삽입 정렬, 선택 정렬



- 해싱 함수
  - 데이터를 키로 변환, 길고 복잡한 문자열을 짧고 단순한 문자열로 변경


- 해싱 함수 종류[산곱숫 폴기무]
  - 제산법(Division)
    - 나머지 연산자(%) 사용해서 테이블 주소 계산
  - 제곱법(Mid Square)
    - 레코드 키값 제곱 후 결괏값 중간 부분에 있는 몇 비트 선택하여 해시 테이블의 홈 주소 사용
  - 숫자 분석법(Digit Analysis)
    - 레코드 키 구성하는 수 자리별로 분포 조사, 고른 분포 나타내는 자릿수 선택 레코드 홈 주소로 사용
  - 폴딩법(Folding)
    - 레코드 키 나누고, 나눈 부분의 각 숫자를 더하거나 XOR 한 값 홈주소 사용
  - 기수 변환법(Radix Conversion)
    - 진법으로 표현된 레코드 다른 진법으로 간주하고 키변환
  - 무작위 방법(Random)
    - 난수 발생 각 레코드 키의 홈 주소 결정


> 검색 알고리즘
- 순차 검색(Sequential Search) O(n)
  - 배열의 처음부터 끝까지 차례대로 비교하여 원하는 데이터 찾아내는 알고리즘
  - 검색할 리스트의 길이가 길면 비효율적
  - 검색 방법 중 가장 단순하여 구현이 쉽고, 정렬되지 않은 리스트에서도 사용할 수 있음


- 이진 검색(Binary Search) O(log2n)
  - 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 알고리즘
  - 탐색 효율이 좋고 탐색 시간 적게 소요


> 정렬 알고리즘
- 퀵 정렬(Quick Sort) O(nlog2n)
  - 피벗을 두고 피벗의 왼쪽에는 피벗보다 작은값을 오른쪽에는 큰 값을 두고 과정 반복 알고리즘
  - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬


- 합병 정렬(Merge Sort) O(nlog2n)
  - 전체 원소를 하나의 단위로 분할 한 후 반할한 원소를 다시 합병해 정렬하는 알고리즘


- 힙 정렬(Heap Sort) O(nlog2n)
  - 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정 반복하여 정렬하는 알고리즘
  - 완전 이진 트리 (Complete Binary Tree)로 입력 자료의 레코드 구성


- 거품 정렬(Bubble Sort) O(n2제곱)
  - 인접한 2개의 레코드 키값을 비교하여 크기에 따라 레코드 위치 서로 교환하는 알고리즘
  - 한 PASS를 수행할 때마다 가장 큰 값이 맨 뒤로 이동하기 때문에 PASS를 '요소의 개수-1'번 수행하게 되면 모든 숫자가 정렬


- 삽입 정렬(Insertion Sort) O(n2제곱)
  - 2번째 키와 첫 번째 키를 비교하여 순서대로 나열
  - 이어서 3번째 키를 1, 2 번째 키와 비교해 순서대로 나열
  - 계속 해서 n번째 키를 앞의 (n-1)개 키와 비교해 알맞은 순서에 삽입하는 알고리즘
  - 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교해 자신 위치 찾아 삽입 정렬 완성

- 선택 정렬(Selection Sort) O(n2제곱)
  - 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬 되지 않은 부분의 가장 앞의 데이터와 교환해나가는 알고리즘


> 버블 정렬은 인접한 두개 값 비교하면서 레코드 위치 교환
>
> 삽입 정렬은 첫번째 두번째 세번째 순서로 있는 값을 순서대로 앞에 있는 값 들과 비교해서 정렬
> 
> 선택 정렬은 가장 작은 데이터 순서로 찾아 정렬 되지 않은 부분 가장 앞 데이터와 교환


- 정적 분석 도구
  - pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura

- 동적 분석 도구
  - Avalanche, Valgrind


- 맥케이브 회전 복잡도(McCabe Cyclomatic Complexity)
  - 제어 흐름을 그래프로 표현하고 소스 코드의 복잡도를 정량적으로 나타내는 지표

- 클린 코드를 저해하는 배드 코드
  - 오염
  - 문서부족
  - 의미없는 이름
  - 높은 결합도
  - 아키텍처 침식
  - 외계인 코드
  - 스파게티 코드
  - 알 수 없는 변수명
  - 로직 중복


- 클린 코드 작성 원칙[가단의 중추]
  - 가독성
  - 단순성
  - 의존성 최소
  - 중복성 제거
  - 추상화


  
- EAI(Enterprise Application Integration) 구축 유형[포허 메하]
  - 포인트 투 포인트(Point-to-Point)
    - 중간에 미들웨어 없이 각가 애플리케이션 간 점대 점 형태로 연결
  - 허브 앤 스포크(Hub & Spoke)
    - 단일한 접점 허브시스템을 통하여 데이터 전송 중앙 집중식 방식
    - 허브 장애 시 전체 장애 발생
  - 메시지 버스(Message Bus)
    - 애플리 케이션 사이 미들웨어 버스를 두어 연계
    - 뛰어난 확장성 대용량 데이터 처리 가능
  - 하이브리드(Hybrid)
    - 그룹 내는 허브 앤 스포크 방식 사용
    - 그룹 간에는 메시지 버스 방식 사용 통합 방식


- ESB(Enterprise Service Bus) 방식
  - 서로 다른 플랫폼 및 애플리케이션들 간 하나의 시스템으로 관리 운영할 수 있또록 서비스 중심의 통합을 지향하는 아키텍처 기술
  - 버스를 중심으로 각각 프로토콜이 호환이 가능하도록 애플리케이션의 통합을 낮은 결합 방식으로 지원


- 인터페이스 보안의 중요성
  - 시스템 모듈 간 통신 및 정보 교환의 중요한 접점이기 때문에 인터페이스 보안 취약성은 시스템에 심각한 피해를 입힐 수 있음


- 인터페이스 보안 취약점
  - 데이터 통신 시 데이터 탈취 위협
  - 데이터 통신 시 데이터 위 변조 위협



- 시큐어 코딩 가이드[입보시에코캡아]
  - 입렵 데이터 검증 및 표현
    - 입력값 검증 누락 부적절한 검증, 잘못된형식 지정
    - 입력 데이터 유효성 검증 체계 수립, 실패 시 처리 설계 및 구현
  - 보안 기능
    - 인증, 접근 제어, 기밀성, 암호화, 권한 관리 등 부적절 구현
    - 인증 접근 통제, 권한 관리, 비밀 번호 등 정책 적절하게 반영
  - 시간 및 상태
    - 동시 수행하는 병렬 시스템
    - 공유 자원의 접근 직렬화, 병렬 실행 가능 프레임워크 사용
  - 에러 처리
    - 에러 미처리, 불충분한 처리등 에러 메시지 중요 정보 포함
    - 에러, 오류 상황 보안 약점 발생하지 않도록 설계 및 구현
  - 코드 오류
    - 개발자가 범할 수 있는 코딩 오류
    - 코딩 규칙 도출 후 검증 가능한 스크립트 구성
  - 캡슐화
    - 기능성 불충분 캡슐화, 데이터 누출
    - 디버거 코드 제거, 필수 정보 외 클래스 private 접근자 지정
  - API 오용
    - 의도된 사용에 반하는 방법 API 사용, 보안 취약 API
    - 개발 언어별 취약 API 확보 및 취약 API 검출 프로그램 사용


- 데이터베이스 암호화 방식[애플하]
  - API 방식
    - 애플리케이션 레벨 암호 모듈 적용
  - Plug-in 방식
    - DB 레벨 확장성 프로시저 기능 이용
  - Hybrid 방식
    - API, Plug-in 방식 결합
    - DB 서버, 애플리케이션 서버 부하 분산



- 중요 인터페이스 데이터의 암호화 전송
  - 민감한 정보를 통신 채널을 통하여 전송 시에는 반드시 암 복호와 과정을 거쳐야 하고 S-HTTP, IPSec, SSL/TLS 등 보안 채널을 활용하여 전송


- 중요 인터페이스 데이터의 암호화 전송 보안 기술
  - S-HTTP(Secure Hypertext Transfer Protocol)
    - 웹상에서 네트워크 트래픽을 암호화하는 주요  바법 중 하나
    - 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송하는 프로토콜
    - S-HTTP에서 메시지 보호는 HTTP를 사용한 애플리케이션에 대해서만 가능
  - IPSec(IP Security)
    - IP계층(3계층)에서 무결성과 인증을 보장하는 인증헤더와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안 서비스를 제공하는 터널링 프로토콜
    - 양방향 암호화, 보안 서비스 제공
    - 동작 모드는 전송 모드와 터널 모드 있음
    - 인증 프로토콜(AH; Authentication Header)
    - 암호화 프로토콜(ESP; Encapsulation Security Payload)
    - 키 관리 프로토콜(IKE; Internet Key Exchange)
  - SSL/TLS
    - 전송계층(4계층)과 응용계층(7계층) 사이에서 클라이언트와 서버 간의 웹 데이터 암호화
    - 상호 인증 및 전송 시 데이터 무결성 보장 보안 프로토콜
    - 익명 모드, 서버 인증 모드, 클라이언트-서버인증 모드 있음
    - Client, Server 간 상호인증, 암호방식에 대해 협상을 거치는 특징
    - 특정 암호 기술에 의존하지 않고 다양한 암호 기술 적용
    - 443 포트 이용


- 인터페이스 데이터 포맷
  - JSON(JavaScript Object Notation)
    - 속성-값 쌍, 키-값 쌍
  - XML(eXtensible Markup Language)
    - 다목적 마크업 언어
  - YAML(YAML Ain't Markup Language)
    - 데이터를 사람이 쉽게 읽을 수 있는 형태 표현, 데이터 직렬화 양식


- 인터페이스 데이터 교환 기술
  - REST(Representational State Transfer)
  - AJAX(Asynchronous JavaScript and XML)

  
- 인터페이스 구현 검증 도구[엑스피 엔셀웨]
  - xUnit
    - jUnit, cppUnit, nUnit, httpUnit 단위 테스트 프레임 워크
  - STAF
    - 각 테스트 대상 분산 환경에 데몬 사용
  - FitNesse
    - 웹 기반 테스트 케이스 설계/실행/결과 확인 등 지원
  - NTAF
    - FitNesse와 STAF의 장점 결합
  - Selenium
    - 다양한 브라우저 지원 및 개발 언어 지원
    - 테스트 스크립트 언어 학습할 필요 없이 기능 테스트 만들기 위한 프렐이백 도구 제공
  - Watir
    - Ruby 기반 웹 애플리케이션 테스트 프레임워크
    - 모든 언어 기반 웹 앱 테스트 브라우저 호환성 테스팅 가능






