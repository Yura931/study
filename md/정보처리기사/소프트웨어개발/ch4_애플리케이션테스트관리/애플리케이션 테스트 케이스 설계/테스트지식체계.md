# 테스트 지식 체계

---

### 소프트웨어 테스트 종류
- 프로그램 실행 여부, 테스트 상세 기법, 테스트에 대한 시각, 테스트의 목적, 테스트의 종류에 따라 분류

### 프로그램 실행 여부에 따른 분류
> 탐색적 테스트(Exploratory Test)
> - 테스트 스크립트 또는 테스트 케이스를 문서로 작성하지 않고 경험에 바탕을 두고 탐색적으로 기능을 수행해 보면서 테스트
> 

- 경험 기반 테스트도 블랙박스 테스트에 포함되기도 함
- 프로그램 실행 여부에 따라 정적 테스트, 동적 테스트 나뉨
- 정적 테스트
  - 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증
  - 리뷰(동료 검토, 워크스루, 인스펙션), 정적분석
- 동적 테스트
  - 소프트웨어를 실행하는 방식으로 테스트 수행, 결함 검출
  - 화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트

### 테스트 기법에 따른 분류

**1. 블랙박스 테스트(Black-box Test)**
- 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능 테스트)
- 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점을 맞춰 테스트 이루어짐
- 기능 및 동작 위주의 테스트를 진행하기 때문에 내부구조나 작동 원리를 알지 못해도 가능
- 명세 테스트라고 부름

#### 블랙박스 테스트 유형[동경결상유분페원비오]
  - 동등 분할 테스트(Equivalence Partitioning Testing)
    - 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값으로 그룹핑하고 대푯값으로 테스트 케이스 도출
  - 경곗값 분석 테스트(Boundary Value Analysis Testing)
    - 등가분할 후 경곗값 부분에서 오류 발생 확률이 높기에 경곗값을 포함하여 테스트 케이스를 설계
    - 최솟값 바로 위 최대치 바로 아래 등 입력값의 극한 한계 테스트
  - 결정 테이블 테스트(Decision Table Testing)
    - 요구사항의 논리와 발생조건을 테이블 형태로 나열
    - 조건과 행위를 모두 조합하여 테스트
  - 상태전이 테스트(State Transition Testing)
    - 테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수 테스트
  - 유스케이스 테스트(Use Case Testing)
    - 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스 명세화하여 수행
  - 분류 트리 테스트(Classification Tree Method Testing)
    - SW의 일부 또는 전체를 트리 구조로 분석 및 표현, 테스트 케이스를 설계하여 테스트
  - 페어와이즈 테스트(Pairwise Testing)
    - 테스트 데이터 간에 최소한 한 번씩을 조합하는 방식
    - 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트
  - 원인-결과 그래프 테스트(Cause-Effect Graph Testing)
    - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스 선정 테스트
  - 비교 테스트(Comparison Testing)
    - 여러 버전의 프로그램에 같은 입력 값을 넣어 동일한 결과 데이터가 나오는지 비교 테스트
  - 오류 추정 테스트(Error Guessing Testing)
    - 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트 케이스 설계
    - 개발자가 범할 수 있는 실수들을 나열하고, 해당 실수에 따른 결함을 노출하는 테스트
    - 다른 블랙 박스 테스트 기법을 보완할 때 사용

**2. 화이트박스 테스트(White-box Test)**
- 각 응용 프로그램의 내부 구조와 동작을 검사하는 테스트
- 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 직접 관찰하고 테스트
- 소스 코드의 모든 문장을 한 번 이상 수행
- 산출물의 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행, 논리적 경로 점검
- 구조 기반 테스트, 코드 기반 테스트, 로직 기반 테스트, 글래스(Glass)박스 테스트라고 부름

#### 화이트박스 테스트 유형[구결조 조변다 기제데루]
- 구문 커버리지 = 문장 커버리지(Statement Coverage)
  - 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 테스트 커버리지
  - 조건문 결과와 관계없이 구문 실행 개수로 계산


- 결정 커버리지 = 선택커버리지(Decision Coverage) = 분기 커버리지(Branch Coverage)
  - (각 분기의) 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행


- 조건 커버리지(Condition Coverage)
  - (각 분기의) 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행


- 조건-결정 커버리지(Condition/Decision Coverage)
  - 전체 조건식뿐 아니라 개별 조건식도 참 한번, 거짓 한 번 결과가 되도록 수행


- 변경-조건-결정 커버리지(Modified Condition/Decision Coverage)
  - 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지


- 다중 조건 커버리지(Multiple Condition Coverage)
  - 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장


- 기본 경로 커버리지 = 경로 커버리지(Base Path Coverage)
  - 수행 가능한 모든 경로를 테스트
  - 기본 경로는 사이클을 허용


- 제어 흐름 테스트(Control Flow Testing)
  - 프로그램 제어구조를 그래프 형태로 나타내어 내부 로직 테스트
  - 구문, 결정, 조건, 조건-결정, 변경 조건-결정, 다중 조건 커버리지 통칭


- 데이터 흐름 테스트(Data Flow Testing)
  - 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트


- 루프 테스트(Loop Testing)
  - 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시


- 구조 테스트의 유형과 화이트박스 테스트 유형은 동일

### 테스트 시각에 따른 분류
**검증(Verification)**
- 개발 과정 테스트
- 올바른 제품 생산하고 있는지 검증
- 이전 단계에서 설정된 개발 규격과 요구를 충족시키는지 판단
- 개발자 혹은 시험자의 시각으로 소프트웨어가 명세환된 기능을 올바로 수행하는지 알아보는 과정

**확인(Validation)**
- 결과 테스트
- 만들어진 제품이 제대로 동작하는지 확인
- 최종 사용자 요구 또는 소프트웨어 요구에 적합한지
- 사용자 시각으로 올바른 소프트웨어가 개발되었는지 입증


### 테스트 목적에 따른 분류[회안성 강 구회병]
**회복 테스트(Recovery Test)**
- 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부 테스트

**안전 테스트(Security Test)**
- 소스 코드 내의 보안적인 결함 미리 점검

**성능 테스트(Performance Test)**
- 사용자의 이벤트에 시스템이 응답하는 시간 
- 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등 측정

**강도 테스트(Stress Test)**
- 부하 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리
- 성능 테스트의 한 종류

**구조 테스트(Structure Test)**
- 시스템의 내부 논리 경로, 소스 코드의 복잡도 평가

**회귀 테스트(Regression Test)**
- 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인
- 일종의 반복 테스트 기법

**병행 테스트(Parallel Test)**
- 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교

### 소프트웨어 테스트의 원리[결완초집 살정오]

**결함 존재 증명**
- 테스트는 결함이 존재함을 밝히는 활동
- 결함이 없다는 것을 증명할 수 없음

**완벽 테스팅은 불가능**
- 무한 경로, 무한 입력값으로 인한 완벽한 테스트 어려움

**초기 집중**
- 개발 초기 체계적 분석 및 설계 수행 -> 테스팅 기간 단축, 재작업 줄임
- 개발 기간 단축 및 결함 예방
- 개발 초기 쳬계적 분석 및 설계 수행되지 못함 -> 프로젝트 후반 영향 미침, 비용 증가 요르돈 법칙 적용(Snowball Effect; 눈덩이 법칙)

**결함 집중**
- 적은 수의 모듈(20%)에서 대다수 결함(80% 결함)이 발견
- 파레토 법칙(Pareto Principle) 80대 20 법칙 적용

**살충제 패러독스**
- 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함

**정황 의존성**
소프트웨어의 성격에 맞게 테스트 수행

**오류-부재의 궤변**
- 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없는 원리


