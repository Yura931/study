# 알고리즘(Algorithm)

---

### 알고리즘 개념
- 어떠한 문제를 해결하기 위한 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 기법

### 알고리즘 특성
- 알고리즘 표현
  - 자연어, 순서도, 의사 코드, 프로그래밍 언어를 이용하는 방법
- 알고리즘 특성
  - 입력 : 외부로부터 입력되는 자료가 0개 이상
  - 출력 : 출력되는 결과가 1개 이상
  - 명확성 : 각 명령어의 의미가 명확
  - 유한성 : 정해진 단계를 지나면 종료
  - 유효성 : 모든 명령은 실행이 가능한 연산들이어야 함

> - 의사 코드(슈도 코드; Pseudo-Code)
>   - 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어
>   - 일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드


### 알고리즘 기법[분동탐백]

**설계 기법**
- 분할과 정복(Divide and Conquer)
  - 문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 다시 병합하여 문제의 답을 얻음
- 동적계획법(Dynamic Programming)
  - 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식
- 탐욕법(Greedy)
  - 결정을 해야할 때마다 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택함으로써 최종적인 해답에 도달하는 방식
- 백트래킹(Backtracking)
  - 어떤 노드의 유망성 점검 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손노드를 검색


### 시간 복잡도에 따른 알고리즘 분류
- Big O 표기법 사용
- **O(1)**
  - 상수형 복잡도
  - 자료 크기 무관하게 항상 같은 속도로 작동
  - 알고리즘 수행 시간이 입력 데이터 수와 관계없이 일정
  - 대표 알고리즘 : 해시 함수(Hash Function)
- **O(log2n)**
  - 로그형 복잡도
  - 문제를 해결하기 위한 단계의 수가 log2n번만큼의 수행 시간을 가짐
  - 대표 알고리즘 : 이진 탐색(Binary Search)
- **O(n)**
  - 선형 복잡도
  - 입력 자료를 차례로 하나씩 모두 처리
  - 수행 시간이 자료 크기와 직접적 관계로 변함(정비례)
  - 대표 알고리즘 : 순차 탐색(Sequential Search)
- **O(nlog2n)**
  - 선형 로그형 복잡도
  - 문제를 해결하기 위한 단계의 수가 nlog2n번만큼의 수행 시간을 가짐
  - 대표 알고리즘 : 퀵 정렬, 합병정렬(병합 정렬), 힙 정렬
- **O(n&#178;)**
  - 제곱형 복잡도
  - 주요 처리 루프 구조가 2중인 경우의 복잡도
  - n의 크기가 작을 때에는 n&#178;이 nlog2n보다 빠를 수 있음
  - 대표 알고리즘 : 거품 정렬, 삽입 정렬, 선택 정렬

### 알고리즘 설명
<strong style="background: #FFD5D2; padding: 5px;">1. 해싱 함수(Hashing Function)</strong>

**1) 해싱함수 개념**
- 데이터를 키로 변환하는 함수
- 길고 복잡한 문자열을 짧고 단순한 문자열(또는 수열)로 변경하는 함수

**2) 해싱함수 종류[산곱숫 폴기무]**
- 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- **제산법(Division)**
  - 나머지 연산자(%)를 사용하여 테이블 주소를 계산
- **제곱법(Mid Square)**
  - 레코드 키값을 제곱한 후 결괏값의 중간 부분에 있는 몇 비트를 선택하여 해시 테이블의 홈 주소로 사용
- **숫자 분석법(Digit Analysis)**
  - 레코드 키를 구성하는 수들이 모든 키들 내에서 자리별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택
  - 레코드의 홈 주소로 사용
- **폴딩법(Folding)**
  - 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용
- **기수 변환법(Radix Conversion)**
  - 어떤 진법으로 표현된 주어진 레코드 키를 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방식
  - 어떤 키 값이 16진법으로 표현되어 있다면 이를 10진법으로 표현된 것으로 간주하고 키 값을 변환하여 홈 주소 계산
- **무작위 방법(Random)**
  - 난수를 발생시켜 각 레코드 키의 홈 주소를 결정하는 방식

- 해싱 함수를 선택할 때 계산과정 단순화, 충돌의 최소화, 기억장소 낭비의 최소화, 오버플로우 최소화 고려

<strong style="background: #FFD5D2; padding: 5px;">2. 검색 알고리즘</strong>

**1) 순차 검색(Sequential Search)**
- 배열의 처음부터 끝까지 차례대로 비교하여 원하는 데이터를 찾아내는 알고리즘
- 검색할 리스트의 길이가 길면 비효율적
- 검색 방법 중 가장 단순하여 구현이 쉬움
- 정렬되지 않은 리스에서도 사용할 수 있음

|1|2|4|5| 10 | 8 |
|---|---|---|---|----|---|

- 리스트에서 10을 찾는다고 가정 시
- 6개의 데이터에서 5번의 시도로 찾을 수 있음
- 순차 검색 5번 시도

**2) 이진 검색(Binary Search)**
- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 알고리즘
- 탐색 효율이 좋고 탐색 시간 적게 소요
- 가운데 레코드 번호를 찾기 위한 식 (소수점이 나올 경우 버림 처리)
- M = (F+L) / 2
  - F : 남은 범위 내에서 첫 번째 레코드 번호
  - L : 남은 범위 내에서 마지막 레코드 번호
  - M : 남은 범위 내에서 가운데 레코드 번호

<strong style="background: #FFD5D2; padding: 5px;">3. 정렬 알고리즘</strong>

**1) 퀵 정렬(Quick Sort)**
- 피벗을 두고 피벗의 왼쪽에는 피벗보다 작은 값을 오른쪽에는 큰 값을 두는 과정을 반복하는 알고리즘
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬
- 수행시간
  - 최적 수행 시간 : O(nlog2n)
  - 평균 수행 시간 : O(nlog2n)
  - 최악 수행 시간 : O(n&#178;)

**2) 합병 정렬(Merge Sort)**
- 전체 원소를 하나의 단위로 분할한 후 분할한 원소를 다시 합병해서 정렬하는 알고리즘
- 수행 시간
  - 최적 수행 시간 : O(nlog2n)
  - 평균 수행 시간 : O(nlog2n)
  - 최악 수행 시간 : O(nlog2n)

**3) 힙 정렬(Heap Sort)**
- 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정 반복 정렬
- 완전 이진 트리(Complete Binary Tree)로 입력 자료의 레코드 구성
- 수행 시간
  - 최적 수행 시간 : O(nlog2n)
  - 평균 수행 시간 : O(nlog2n)
  - 최악 수행 시간 : O(nlog2n)

**4) 거품 정렬(Bubble Sort)**
- 인접한 2개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 알고리즘
- 두 인접한 원소를 교환하는 과정이 거품 모양과 같다고 하여 거품 정렬이라는 이름 지어짐
- 한 PASS를 수행할 때마다 가장 큰 값이 맨 뒤로 이동하기 때문에 PASS를 '요소의 개수-1'번 수행하게 되면 모든 숫자가 정렬

**5) 삽입 정렬(Insertion Sort)**
- 2번째 키와 첫 번째 키를 비교하여 순서대로 나열
- 이어서 3번째 키를 1, 2 번째 키와 비교해 순서대로 나열
- 계속해서 n번째 키를 앞의 (n-1)개 키와 비교하여 알맞은 순서에 삽입하는 알고리즘
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘

**6) 선택 정렬(Selection Sort)**
- 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 알고리즘

