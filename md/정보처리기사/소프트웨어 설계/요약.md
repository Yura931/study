# 요구사항 확인

- 플랫폼의 유형[싱투멀]
  - 싱글 사이드
    - 제휴 관계를 통해 소비자 공급자 연결
  - 투 사이드
    - 두 그룹 중개 모두에게 개방
  - 멀티 사이드
    - 다양한 이해관계 그룹 연결


- 플랫폼 기능 분석 절차
  - 자료수집 -> 자료 분석 -> 결과 산출물


- 플랫폼 성능 특성 분석 기법
  - 사용자 인터뷰
  - 성능 테스트
  - 산출물 점검


- 플랫폼 성능 특성 측정 항목[경사응가]
  - 경과시간(Turnaround Time)
    - 작업 의뢰(요구)한 시간부터 처리가 완료될 때까지
  - 사용률(Utilization)
    - CPU, 메모리 등의 자원 사용률
  - 응답시간(Response Time)
    - 요청 전달 시간부터 응답 도착 할 때까지
  - 가용성(Availability)
    - 정보 시스템이 정상적으로 사용 가능한 정도


- 운영체제 현행 시스템 분석
  - 품질 측면
    - 신뢰도
    - 성능
  - 지원 측면
    - 기술 지원
    - 주변 기기
    - 구축 비용


- 운영체제 종류
  - 윈도즈 : 중 / 소규모
  - 유닉스 : 대용량 처리
  - 리눅스 : 중 / 대규모 서버 대상, 하드웨어 및 소프트웨어 소유비용 가작 적게 소요
  - 안드로이드
  - IOS



- DBMS 현행 시스템 분석 시 고려사항 [가성호기구]
  - 성능측면
    - 가용성
    - 성능
    - 상호 호환성
  - 지원측면
    - 기술 지원
    - 구축 비용


- 비지니스 융합 유형
  - 고객 가치(Why)
  - 공급 역량(Who)
  - 시장 유통(Whom)
  - 가치 제안(What)
  - 생산 방식(How)
  


- 요구사항 분석 단계 절차
  - 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 요구사항 할당 -> 요구사항 협상 -> 정형 분석


- 요구사항 분석 기술
  - 청취 기술
  - 인터뷰와 질문 기술
  - 분석 기술
  - 중재 기술
  - 관찰 기술
  - 작성 기술
  - 조직 기술
  - 모델 작성 기술



- 데이터 흐름도 DFD(Data Flow Diagram)
  - 구조적 분석 기법에 이용
  - 데이터 흐름에 중심
  - 제어의 흐름은 중요하지 않음
  - 시간 흐름을 명확하게 표현할 수 없음


- 데이터 흐름도 구성요소[프플스터]
  - process(처리기) 원
    - 출력 요소
  - Data Flow(데이터 흐름) 화살표
    - 주고받는 데이터 흐름
  - Data Store(데이터 저장소) 평행선
    - 데이터가 저장된 장소
  - Terminator(터미네이터) 사각형
    - 데이터 발생 시작과 종료


- 자료사전 DD; Data Dictionary 기호
  - = 
    - 자료의 정의, ~으로 구성되어 있다.
  - \+
    - 자료의 연결
  - ()
    - 자료의 생략
  - {}
    - 자료의 반복
  - []
    - 자료 선택
  - ** 
    - 주석



- UML(Unified Modeling Language)
  - 객체 지향 소프트웨어 개발 과정에서 사용
  - 표준화된 범용 모델링 언어


- UML 특징 [가구명문]
  - 가시와
  - 구축 언어
  - 명세화 언어
  - 문서화 언어


- UML 구성요소[사관다]
  - 사물(Things)
    - 추상적 개념, 주제 나타냄
  - 관계(Relationships)
    - 사물과 사물을 연결하여 관계 표현
  - 다이어그램(Diagrams)
    - 사물과 관계를 모아 그림으로 표현

- UML 사물(Things)
  - 구조 사물
  - 행동 사물
  - 그룹 사물
  - 주해 사물


- 구조적 다이어그램(Structure Diagram) / 정적 다이어그램(Static Diagram)[클객 컴배 복패]
  - 클래스(Class)
    - 클래스 내 정적구조
    - 속성과 동작
  - 객체(Object)
    - 클래스에 속한 사물들, 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
    - 모든 인스턴스 표현
  - 컴포넌트(Component)
    - 코드 컴포넌트 기반 물리적 구조 표현
    - 실질적 프로그래밍 작업에 사용
  - 배치(Deployment)
    - 컴포넌트 사이 종속성 표현
  - 복합체(Composite Structure)
    - 클래스, 컴포넌트 복합구조 갖는 경우 내부 구조 표현
  - 패키지(Package)
    - 유스케이스, 클래스 등 모델 요소들을 그룹화한 패키지들 관계 표현


- 행위적 다이어그램(Behavioral Diagram) / 동적 다이어그램(Dynamic Diagram)[유시커 상활타]
  - 유스케이스(Usecase)
    - 사용자 관점에서 시스템의 활동 표현
    - 기능적 요구 정의에 활용
  - 시퀀스(Sequence)
    - 상호 작용 메시지 흐름으로 표현
    - 메시지 보내는 시간 표현
  - 커뮤니케이션(Communication)
    - 동작에 참여하는 객체들이 주고받는 메시지 표현
    - 객체 간 연관 까지 표현
  - 상태(State)
    - 모든 가능한 상태와 전이를 표현
    - 상태 변화, 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지
  - 활동(Activity)
    - 시스템이 어떤 기능을 수행하는지
    - 처리로직, 조건에 따른 처리 흐름
    - 활동 순서
  - 타이밍(Timing)
    - 객체 상태 변화, 시간 제약 명시적 표현



- 클래스 다이어그램
  - 클래스의 속성 및 연산
  - 클래스 간 정적인 관계 표현


- 클래스 다이어그램 구성요소
  - 클래스 이름(Class Name)
  - 속성(Attribute)
  - 연산(Operation)
    - 클래스의 동작 의미
  - 접근 제어(Access Modifier)
    - \- 클래스 내부 접근만 허용(private)
    - \+ 클래스 외부 접근 허용(public)
    - \# 동일 패키지 파생 클래스에서 접근 가능(protected)
    - \~ 동일 패키지 클래스에서 접근 가능(default)


- 유스케이스 다이어그램
  - 시스템이 제공하고 있는 기능 및 관련된 외부 요소를 사용자의 관점에서 표현


- 유스케이스 다이어그램 구성요소[유액시]
  - 유스케이스(Usecase)
    - 시스템이 제공해야 하는 서비스
    - 액터가 시스템을 통해 수행하는 일련의 행위
  - 액터(Actor)
    - 사용자가 시스템에 대해 수행하는 역할
    - 시스템과 상호작용
    - 사람 또는 사물
    - 역할 중심 추상화 정의
    - 하나의 액터 여러 유스케이스와 상호작용
  - 시스템(System)
    - 전체 시스템 영역



- 유스케이스 다이어그램 구성요소 간 관계[연포확일]
  - 연관 관계(Association)
    - 유스케이스와 액터 간 상호작용 있음
    - 실선 연결
  - 포함 관계(Include)
    - 하나의 유스케이스가 다른 유스케이스 실행을 전제로
    - 화살표를 점선 연결 <<include>> 표기
  - 확장 관계(Extend)
    - 특정 조건에 따라 확장 기능 유스케이스 실행
    - 화살표를 점선 연결 <<extend>> 표기
  - 일반화 관계(Generalization)
    - 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스
    - 액터와 연결시켜 그룹을 만들어 이해도 높이기 위한 관계



- 시퀀스 다이어그램(Sequence Diagram)
  - 객체 간 상호작용을 메시지 흐름으로 표현


- 시퀀스 다이어그램 구성요소
  - 객체(Object)
  - 생명선(Lifeline)
  - 실행(Activation)
    - 직사각형은 오퍼레이션이 실행되는 시간 의미
    - 길어질 수록 오퍼레이션 수행시간 긺
  - 메시지(Message)
  - 회귀 메시지(Self-Message)


- 상태 다이어그램
  - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현



- 상태 다이어그램 구성요소
  - 상태(state)
    - 객체가 존재할 수 있는 조건
  - 시작 상태(initial State)
    - 객체의 시작 상태
  - 종료 상태(Final State)
    - 객체의 종료 상태
  - 전이(Transition)
    - 객체의 상태가 다른 상태로 변경되는 상태
  - 이벤트(Event)
    - 상태의 변화를 주는 현상
  - 전이 조건(Transition Condition)
    - 특정 조건 만족 시 전이가 발생하도록 하기위해 사용되는 불린 식


- UML 관계[연의 일실 포집]
  - 연관 관계(Association)
    - 2개 이상 사물 서로 관련
    - 사물 사이 실선 연결, 방향성 화살표
    - 양방향 관계의 경우 화살표 없이 실선
  - 의존 관계(Dependency)
    - 필요에 따라 서로에게 영향을 주는 짧은 시간 동안만 연관 유지
    - 사물의 변화가 다른 사물에도 영향 미치는 관계
    - 영향 주는 사물이 영향 받는 사물 쪽으로 점선 화살표
  - 일반화 관계(Generalization)
    - 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
    - 일반적 개념 상위, 구체적 개념 하위
    - 구체적 사물에서 일반적 사물 쪽으로 속빈 화살표 연결
  - 실체화 관계(Realization)
    - 다른 객체에 오퍼레이션 수행하도록 지정
    - 사물에서 기능 쪽으로 속이 빈 점선 화살표 연결
  - 포함 관계(Composition)
    - 포함하는 사물의 변화가 포함되는 사물에 영향을 미치는 관계
    - 포함되는 쪽(부분)에서 포함하는 쪽(전체)으로 속이 채워진 마름모 연결
  - 집합 관계(Aggregation)
    - 하나의 사물이 다른 사물에 포함된 관계 표현
    - 포함되는 쪽에서 포함하는 쪽으로 속 빈 마름모 연결


 
- UML 확장 모델의 스테레오 타입(Stereotype)
  - <<>> 길러멧 기호 사용
  - \<\<include>>
  - \<\<extende>>
  - \<\<interface>>
  - \<\<entity>>
  - \<\<boundary>>
  - \<\<control>>


- 애자일(Agile)
  - 소프트웨어 개발 방법론
  - 개발과 함께 즉시 피드백을 받아 유동적으로 개발



- 애자일 방법론 특징
  - 프로젝트의 요구사항 기능 중심 정의
  - 절차와 도구보다 개인과 소통 중요
  - 작업 계획 짧게 세워 요구 변화에 유연하고 신속 대응
  - 소프트웨어가 잘 실행되는 데 가치 둠
  - 고객과의 피드백 중요


- 애자일 선언문[개변동고]
  - 공정과 도구보다 개인과 상호 작용
  - 계획을 따르기 보다 변화에 대응
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력


- 애자일 방법론 유형
  - XP, 린(Lean), 스크럼(SCRUM)


- XP(eXtreme Programming)
  - 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
  - 실용성 강조
  - 1~3주기 반복 개발 주기
  - 5가지 가치, 12가지 실천항목


- XP의 5가지 가치[용단의피존]
  - 용기(Courage)
  - 단순성(Simplicity)
  - 의사소통(Communication)
  - 피드백(Feedback)
  - 존중(Respect)


- XP의 12가지 기본원리
  - 짝 프로그래밍(Pair Programming)
  - 공동 코드 소유(Collective Ownership)
  - 지속적인 통합(CI; Continuous Integration)
  - 계획 세우기(Planning Process)
  - 작은 릴리즈(Small Release)
  - 메타포어(Metaphor)
  - 간단한 디자인(Simple Design)
  - 테스트 기반 개발(TDD; Test Driven Development)
  - 리팩토링(Refactoring)
  - 40시간 작업(40-Hour Work)
  - 고객 상주(On Site Customer)
  - 코드 표준(Coding Standard)


- 스크럼
  - 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론



- 스크림 주요 용어
  - 제품 책임자(Product Owner)
    - 개발 의뢰자나 사용자가 담당
    - 개발될 제품에 대한 이해도 높고 요구사항 책임지고 의사 결정할 사람
  - 제품 백로그(Product Backlog)
    - 스크럼 팀이 해결해야 하는 목록
  - 스프린트(Sprint)
    - 2~4주의 짧은 개발 기간으로 반복적 수행
  - 스크럼 미팅(Scrum Meeting)
    - 매일 15분 정도 미팅 To Do List 
    - 데일리 미팅
  - 스크럼 마스터(Scrum Master)
    - 프로젝트 리더
    - 팀이 스크럼을 효과적으로 활용할 수 있또록 보장
  - 스프린트 회고(Sprint Retrospective)
    - 스프린트 주기 되돌아보기
    - 규칙 준수 여부, 개선점 등 확인
    - 스프린트 끝난 시점이나 일저 주기로 시행
  - 번 다운 차트(Burn Down Chart)
    - 남아있는 백로그 대비 시간 표현
  - 속도(Velocity)
    - 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지


- 린(Lean)
  - 도요타의 린 시스템 품질 기법을 소프트웨어 개발프로세스에 적용
  - 낭비 요소 제거 품질 향상
  - 칸반 보드 사용


- 크리스탈
  - 사람에게 중점
  - 최대 6명 또는 8명의 공동 배치 소프트웨어 개발자 팀에 적용


- ASD(Adaptive Software Development)
  - 개발을 혼란 자체로 규정
  - 혼란을 대전제로 적응할 수 있는 소프트웨어 방법 제시 방법론
  - 합동 애플리케이션 개발 사용


- FDD(Feature Driven Development)
  - 개발을 상품이나 서비스 단위가 아니라 신규 기능 단위로 개발


- 모델 특징
  - 소프트웨어 대한 이해도 향상
  - 이해 당사자 간 의사소통 향상
  - 문제가 발생하는 상화에 대한 이해를 높이고 해결책 설명
  - 향후 개발될 시스템에 대한 유추 가능
  - 문제 도메인의 엔터티들과 관계 및 종속성 반영


- 모델링
  - 실세계의 물리현상 쉬운 형식으로 표현


- 모델링 특징
  - 여러 분야 엔지니어들이 공통된 개념 공유
  - 응용문제 이해 도움
  - 모델링 작업의 결과물은 다른 모델링 작업에 영향 줄 수 있음
  - 구조적 방법론 DFD, DD 사용
  - 객체지향 방법론 UML표기법 사용
  - 실세계 문제에 대한 모델링 -> 요구사항 분석의 핵심


- 분석 자동화 도구
  - 요구사항 자동 분석, 요구사항 분석 명세서 기술
  - CASE(Computer Aided Software Engineering)


- 분석 자동화 도구 특징
  - 표준화 적용 문서화를 통한 보고 품질 개선
  - 변경사항, 변경으로 인한 영향 추적 쉬움
  - 명세에 대한 유지보수 비용 축소 가능
  - 자동화된 기법, 소프트웨어 품질 향상
  - 모듈 재사용성 향상, 유지보수 용이
  - 구조적 기법, 프로토타이핑 기술, 자동프로그래밍 기술, 정보 저장소 기술, 분산 처리 기술 사용


- 분석 자동화 도구의 분류
  - 상위 CASE
    - 계획수립, 요구분석, 기본설계 단계 다이어그램 표현
    - 모델들 사이 모순 검사
    - 모델의 오류 검증 기능
    - 자료 흐름도 작성 기능
  - 하위 CASE
    - 구문 중심 편집 및 정적, 동적 테스트 지원
    - 소스 코드 생성 기능
  - 통합 CASE
    - SW 개발 주기 전체 지원


- 분석 자동화 도구(CASE 도구) 주요기능
  - 그래픽을 지원
  - 소프트웨어 생명주기 전 단계 연결
  - 다양한 소프트웨어 개발 모형 지원
  - 표준화된 개발 환경 구축 및 문서 자동화 기능 제공
  - 작업 과정 및 데이터 공유 통해 작업자 간 커뮤니케이션 증대


- 요구사항 관리 도구
  - 프로젝트 관리, 설계, 개발, 테스트 등 수행할 수 있는 역할 지원


- 요구사항 관리 도구의 필요성
  - 비용 편익
  - 변경 추적
  - 영향 평가


---

# 02 화면 설계

- UI(User Interface)
  - 사용자와 시스템 사이 의사소통, 물리적, 가상 매개체
  - 종보기기나 소프트웨어 화면 등에서 사람이 접하게 되는 화면


- UI 유형
  - GUI
    - 그래픽 환경 기반, 마우스나 전자펜 이용
  - CLI
    - 명령어 텍스트 입력 조작
  - NUI
    - 사용자가 가진 경험 기반
    - 키보드나 마우스 없이 신체 부위 이용(터치, 음성)
  - OUI
    - 입력장치가 곧 출력장치
    - 모든 사물이 입출력장치로 변화


- UI 특징
  - 오류 최소화
  - 작업기능 구체화
  - 상호 작용
  - 작업시간 감소
  - 피드백 제공


- UI 설계 원칙[직유학유]
  - 직관성(Intuitiveness)
    - 누구나 쉽게 이해, 쉽게 사용
  - 유효성(Effectiveness)
    - 정확하고 완벽
    - 사용자 목표 달성
  - 학습성(Learnability)
    - 모두 쉽게 배우고 사용
  - 유연성(Flexibility)
    - 사용자 인터랙션 최대한 포용
    - 실수 방지


- UI 설계 지침
  - 사용자 중심
  - 효율성
  - 일관성
  - 단순성
  - 결과 예측 가능
  - 가시성
  - 표준화
  - 접근성
  - 명확성
  - 오류 발생 해결

- UI 표준
  - 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 규약


- UI 표준 구성[액정 스패조]
  - 전체적인 UX원칙
  - 정책 및 철학
  - UI 스타일 가이드
  - UI 패턴 모델정의
  - UI 표준 수립을 위한 조직 구성


- UI 화면 구성요소
  - 그리드
    - 테이블 형태 UI
  - 버튼/컨트롤 타입
    - 사용자로부터 입력
    - 콤보 박스, 토글 버튼, 텍스트 박스, 라디오 버튼, 체크 박스
  - Page 요소
    - 폰트규정, 아이콘 요소, 체크박스/라디오 버튼, 말풍선, 이미지 표시, 탭 표시, 스텝 표시, 페이지 이동, 상하 스크롤, 정보입력 등
  - 팝업 요소
    - 윈도 팝업, 레이어 팝업
  - Alert 요소
    - 정보 누락/오류, 업무 처리 완료, 삭제/수정, 업무 안내


- UI 제스처
  - 탭
  - 더블 탭
  - 프레스
    - 화면 길게 꾹
  - 플릭
    - 수평, 수직 방향으로 빠르게 밈
  - 스와이프
    - 화면 터치한 상태로 드래그
  - 팬
    - 화면에서 손을 떼지 않고 드래그
  - 드레그
  - 핀치
    - 두 손가락 터치한 상태에서 손가락 사이 벌리거나 좁히는 제스처
  - 로테이트
    - 두 손가락을 터치한 상태에서 손가락 회전


- 스토리 보드
  - UI 화면 설계를 위해 정책이나 프로세스 및 컨텐츠의 구성, 와이어 프레임, 기능에 대한 정의, 데이터베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서


- UI 화면 설계 구분[와스프]
  - 와이어프레임(Wireframe)
  - 스토리보드(Storyboard)
  - 프로토타입(Prototype)


- UI 설계 프로세스[문사 작컴 인디]
  - 문제정의
  - 사용자 모델 정의
  - 작업 분석
  - 컴퓨터 오브젝트 및 기능 정의
  - 사용자 인터페이스 정의
  - 디자인 평가


- UI 흐름 설계[기입유양]
  - 화면에 표현되어야 할 기능 작성
  - 화면의 입력 요소 확인
  - UI 요구사항을 기반으로 유스케이스 설계
  - 기능 및 양식 확인

    
- UI 설계 도구
  - 비용 절감 목적으로 실제 제품이 나오기 전 만드는 모형 목업 활용


- 감성공학 접근 방법
  - 1류
    - 인간의 감성 표현하는 어휘 이용
    - 제품 이미지 조사
  - 2류
    - 문화적 감성의 일부 반영
    - 생활 방식으로부터 개인이 갖고 있는 이미지 구체화
    - 감성의 심리적 특성
  - 3류
    - 공학적인 방법 접근
    - 수학적 모델 구축 활용
    - 감성의 생리적 특성 강조
   

---

# 03 애플리케이션 설계

- 재사용
  - 기존 소프트웨어 또는 소프트웨어 지식을 활용하여 새로운 소프트웨어 구축


- 재사용의 유형
  - 함수와 객체 재사용
  - 컴포넌트 재사용
  - 애플리케이션 재사용


- 모듈
  - 독립된 하나의 소프트웨어 또는 하드웨어 단위


- 모듈의 특징
  - 독립성
  - 다양한 조합
  - 재사용
  - 영향 최소화


- 공통 모듈 원칙[정명 완일추]
  - 정확성(Correctness)
    - 기능이 실제 시스템 구현시 필요한지
  - 명확성(Clarity)
    - 일관되게 이해되고 한 가지로 해석
  - 완전성(Completeness)
    - 요구되는 모든 것 기술
  - 일관성(Consistency)
    - 공통 기능 간 상호 충돌 없도록
  - 추적성(Traceability)
    - 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별 가능하도록


- 모듈화
  - 프로그램이 효율적으로 관리될 수 있또록 시스템을 분해하고 추상화
  - 제품 성능 향상, 시스템 수정 및 재사용, 유지관리 쉽게 하는 기법


- 모듈화 기법
  - 루틴
    - 특정 동작 수행하는 일련의 코드
  - 메인 루틴
    - 프로그램의 주요한 부분
    - 서브 루틴 호출
  - 서브 루틴
    - 메인 루틴에 의해 필요할 때마다 호출 됨



- 바람직한 모듈 설계 방안
  - 결합도는 낮추고 응집도는 높임
  - 복잡도 중복성 줄이고 일관성 유지
  - 기능 예측 가능해야 함, 지나치게 제한적이어서는 안 됨
  - 적당한 모듈의 크기 유지
  - 모듈 간 효과적 제어를 위해 설계에서 계층적 자료 조직 제시
  - 유지보수 용이, 이식성 고려


- 모듈 측정 지표
  - 응집도(Cohesion)
    - 내부 요소들 관련 정도
    - 독립적인 기능으로 정의되어 있는 정도
  - 결합도(Coupling)
    - 모듈 간 상호 의존 정도


- 응집도(Cohesion) 유형[우논시절 통순기]
  - 우연적(Coincidental)
    - 서로 어떠한 의미가 없는 기능 요소들
    - 서로 다른 상위 모듈에 의해 호출 처리상 연관 없음
  - 논리적(Logical)
    - 유사한 성격, 특정 형태로 분류
  - 시간적(Temporal)
    - 특정 시간에 처리되어야 하는 활동들
  - 절차적(Procedural)
    - 다수 관련 기능, 기능 순차적 수행
  - 통신적(Communication)
    - 동일한 입출력 사용, 다른 기능 수행하는 활동들이 모여 있을 경우
  - 순차적(Sequential)
    - 한 활동으로부터 나온 출력값을 다른 활동이 사용
  - 기능적(Functional)
    - 모든 기능이 단일한 목적


- 결합도 유형[내공 외제 스자]
  - 내용(Content)
    - 직접적으로 다른 모듈의 내용 참조
  - 공통(Common)
    - 전역 변수 참조
    - 공통 데이터 영역 여러 모듈이 사용
  - 외부(External)
    - 외부에서 도입된 데이터 포맷, 통신 프로토콜 또는 디바이스 인터페이스 공유
  - 제어(Control)
    - 다른 모듈의 내부 논리 조직 제어
    - 하위 모듈에서 상위 모듈로 제어 신호 이동, 상위 모듈에게 처리 명령 부여
    - 권리 전도 현상
  - 스탬프(Stamp)
    - 배열이나 객체, 구조 등이 전달
    - 동일한 자료 구조를 조회하는 경우
    - 자료 구조의 어떠한 변환느 모든 모듈에 영향
  - 자료(Data)
    - 인터페이스로 전달되는 파라미터를 통해서만 모듈 간 상호 작용 일어남


- 팬인 
  - 어떤 모듈을 제어하는 모듈의 수


- 팬 아웃
  - 어떤 모듈에 의해 제어되는 모듈의 수



- 설계 모델링 원칙
  - 소프트웨어 설계는 변경이 쉽도록 구조화 되어야 함
  - 하나의 함수 안에 특정 기능을 수행하는 데 필요한 자료만 사용
  - 독립적이고 기능적인 특성을 지닌 모듈 단위로 분할 설계
  - 계층적 구조



- 설계 모델링 유형
  - 구조 모델링
    - 시스템 구성요소들과 이들 사이의 구조적 관게, 특성
  - 행위 모델링
    - 구성요소들의 기능들과, 이들이 언제 어떠한 순서로 기능을 수행하고 상호 작용하는지



- 소프트웨어 설계 유형
  - 자료 구조 설계
  - 아키텍처 설계
  - 인터페이스 설계
  - 프로시저 설계
  - 협약에 의한 설계
    - 선행조건(Procondition)
      - 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 선행 조건
    - 결과조건(Postcondition)
      - 사용 후 만족하여야 할 결과 조건
    - 불변조건(invariant)
      - 오퍼레이션이 실행되는 동안 항상 만족하여야 할 불변 조건


- 아키텍처 설계 과정
  - 설계 목표 설정
  - 시스템 타입 설정
  - 스타일 적용 및 커스터마이즈
  - 서브시스템의 기능
  - 인터페이스 동작 작성
  - 아키텍처 설계 검토


- 소프트웨어 설계 원리
  - 상향식 설계(Bottom-Up Design)
    - 하위 기능들로 시작해 상위 기능에 접근 방식
    - 인터페이스가 성립되어 있어야 기능 추가 쉬움
    - 기존 컴포넌트 조합으로 시스템 개발하는 경우
  - 하향식 설계(Top-Down Design)
    - 제일 상위에 있는 기능에서 시작해 하위 기능들로 분할해 가면서 설계
    - 레벨이 낮은 데이터 구조의 세부사항은 설계 초기 단계에서 필요
    - 통합 검사 시 인터페이스가 이미 정의되어 있어 통합 간단


- 코드의 기능
  - 표준화
  - 분류
  - 식별
  - 배열
  - 간소화
  - 연상
  - 암호화
  - 오류 검출


- 코드 설계 종류
  - 연상 코드(Mnemonic Code)
    - 코드만 보고 대상 연상
    - 나라 이름(한국 : KR, 미국 : US ..)
  - 블록 코드(Block Code)
    - 공통성 있는 것끼리 블록으로 구분
    - 전화번호(지역번호 - 국번- 일련번호 조합에서 지역 번호 - 국번 같은 지역끼리 공통)
  - 순차 코드(Sequence Code)
    - 일정한 기준에 따라 순서대로 일련번호 부여
    - 중고등 학생들의 반에서 번호(가나다순으로 1번, 2번)
  - 표의 숫자 코드(Significant Digit Code)
    - 대상 자료의 물리적 수치
    - 20-10-300(길이-넓이-용량 조합)
  - 십진 코드(Decimal Code)
    - 10진수 형태로 표현
    - 상품 바코드(880...)
  - 그룹 분류식 코드(Group Classification Code)
    - 대상을 기준에 따라 대 분류, 중분류, 소분류로 구분
    - 학번(입학 연도 - 일련번호 조합)


- 코드 오류 종류
  - 사본 오류(Transcription Error)(= 필사 오류, 오자 오류)
    - 한 자리 잘못 표기한 경우
  - 전위 오류(Transposition Error)
    - 연속된 두 글자가 서로 바뀌어 표기
  - 생략 오류(Omission Error)
    - 한 글자 빼먹고 기술
  - 첨가 오류(Addition Error)
    - 한 글자 추가되어 기술
  - 이중 전위 오류(Double Transposition Error)
    - 전위 오류 중복 발생


- HIPO(Hierarchy Input Process Output)
  - 시스템의 분석 및 설계, 문서화할 때 사용되며, 하향식 소프트웨어 개발을 위한 문서화 도구


- HIPO 특징
  - 체계적인 문서 관리 가능
  - 기호, 도표 등을 사용해서 보기 쉽고 이해 쉬움
  - 기능과 자료의 의존 관계를 동시에 표현
  - 변경, 유지보수 용이
  - 시스템의 기능을 고유 모듈들로 분할하여 이들 간 인터페이스를 계층 구조로 표현 한 것 HIPO Chart라고 함


- HIPO 차트 종류[가총세]
  - 가시적 도표(Visual Table of Contents)
    - 시스템 전반적 기능과 흐름, 계층 구조도
  - 총체적 도표(Overview Diagram)
    - 입력, 처리, 출력에 대한 정보 제공
    - 프로그램 구성 기능
  - 세부적 도표(Detail Diagram)
    - 총체적 도표에 표시된 기능 요소들 상세히 기술


- 소프트웨어 아키텍처
  - 소프트웨어 구성요소가 가진 특성 중 외부에 드러나는 특성, 구성요소 간의 관계를 표현하는 시스템 구조
  - 비기능적인 요소에 집중해서 만들어지지만 기능적 요소도 고려


- 소프트웨어 아키텍처 4+1뷰
  - 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
  - 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사하을 충족시키는지 증명하기 위해 유스케이스 사용

    
- 소프트웨어 아키텍처 4+1뷰 구성요소[유논프구배]
  - 유스케이스 뷰(Usecase View)
    - 외부 행위자에 의해 인식되는 시스템의 기능 요구사항 보여주는 데 초점
    - 사용자, 설계자, 개발자, 테스트 관점
  - 논리 뷰(Logical View)
    - 기능적 요구사항 어떻게 제공되는지
    - 설계자, 개발자 관점
  - 프로세스 뷰(Process View)
    - 비기능적 속성
    - 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등 표현
    - 개발자, 시스템 통합자
  - 구현 뷰(Implementation View)
    - 컴포넌트 구조와 의존성
    - 컴포넌트에 관한 부가적 정보 정의
    - 정적 소프트웨어 모듈 구성 보여줌
  - 배포 뷰(Deployment View)
    - 물리적인 아키텍처에 어떻게 배치되는가
  


- 소프트웨어 아키텍처 비용 평가 모델[SACAA(사카)]
  - SAAM(Software Architecture Analysis Method)
    - 변경 용이성과 기능성에 집중
    - 평가가 용이하여 경험이 없는 조직에서도 활용 가능
  - ATAM(Architecture Trade-off Analysis Method)
    - 아키텍처 품질 속성을 만족시키는지 판단
    - 품질 속성들의 이해 상충 관계까지 평가
  - CBAM(Cost Benefit Analysis Method)
    - ATAM 바탕의 시스템 아키텍처 분석 중심
    - 경제적 의사결정에 대한 요구를 충족
  - ADR(Active Design Review)
    - 구성요소 간 응집도 평가
  - ARID(Active Reviews for Intermediate Designs)
    - 특정 부분에 대한 품질요소에 집중


- 소프트웨어 아키텍처 패턴
  - 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조


- 소프트웨어 아키텍처 패턴 유형
  - 계층화 패턴(Layered Pattern)
    - 시스템을 계층으로 구분하여 구성
  - 클라이언트 서버 패턴(Client-Server Pattern)
    - 하나의 서버와 다수의 클라이언트로 구성
  - 파이프 필터 패턴(Pipe-Filter Pattern)
    - 단방향 패턴
    - 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정 반복
    - 컴포넌트 재사용성 좋음
    - 확장 용이
    - 필터 간 데이터 이동에서 데이터 변환 오버헤드 발생
  - 브로커 패턴(Broker Pattern)
    - 분산 시스템에서 사용
    - 분리된 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능
    - 컴포넌트 간 통신 조정
    - 서버가 기능들 브로커에 넘겨줌, 클라이언트 브로커에 서비스 요청 -> 브로커가 적합한 서비스로 리다이렉션
  - 모델 뷰 컨트롤러 패턴(MVC; Model View Controller Pattern)
    - 대화형 애플리케이션 모델, 뷰, 컨트롤러 3개 서브시스템으로 구조화
    - 모델
      - 핵심 기능과 데이터 보관
    - 뷰
      - 사용자에게 정보 표시
    - 컨트롤러
      - 모델과 뷰 사이 전달자 역할 수행
    - 각 부분이 별도의 컴포넌트, 서로 영향 받지 않고 개발 작업
    - 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합
  - 마스터 슬레이브 패턴(Master-Slave Pattern)
    - 연산, 통신, 조정을 책임지는 마스터
    - 제어되고 동기화 되는 대상  슬레이브
    - 실시간 시스템에서 사용


- 소프트웨어 아키텍처 품질 속성
  - 시스템 품질 속성[가변성 보사시]
    - 가용성, 변경용이성, 성능, 보안성, 사용 편의성, 시험 용이성
  - 비즈니스 품질 속성[시비프 목신노]
    - 시장 적시성, 비용과 이익, 시스템 프로젝트 생명주기, 목표 시장, 신규 발매 일정, 노후 시스템과 통합
  - 아키텍처 품질 속성[개무 정안 개용]
    - 개념적 무결성, 정확성 안정성, 개발 용이성



- 객체 지향(Object Oriented)
  - 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현


- 객체 지향 구성요소[클객메 메인속]
  - 클래스(Class)
    - 하나 이상의 유사한 객체들을 묶어 하나의 공통된 특성 표현
  - 객체(Object)
    - 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대상
  - 메서드(Method)
    - 클래스로부터 생성된 객체를 사용하는 방법
    - 객체의 구체적인 연산
  - 메시지(Message)
    - 객체 간 상호 작용을 하기 위한 수단
    - 행위 지시
  - 인스턴스(Instance)
    - 클래스를 통해 만든 실제의 실형 객체
  - 속성(Property)
    - 객체들이 가지고 있는 데이터 값들



- 객체 지향 기법[캡상다 추정관]
  - 캡슐화(Encapsulation)
    - 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 바깥으로 드러내는 기법
    - 변경 발생 시 오류의 파급 효과 적음
  - 상속성(Inheritance)
    - 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용
  - 다형성(Polymorphism)
    - 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답
    - 상속 받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용
  - 추상화(Abstraction)
    - 공통 성질을 추출하여 추상 클래스 설정
    - 추상화 기법[과자제]
      - 과정 추상화, 자료 추상화, 제어 추상화
  - 정보 은닉(Information Hiding)
    - 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근 가능하도록 하는 코드 보안 기술
    - Side-Effect 최소화
    - 요구사항 등 변화에 따른 수정 가능
  - 관계성(Relationship)
    - 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타냄
    - 종류
      - 연관화 : is-member-of, 클래스와 객체의 참조 및 이용관계
      - 분류화 : is-part of, part-whole, 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체 만듦, 상위 클래스 성질 하위클래스로 상속X
      - 집단화 : is -instance-of, 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스
      - 일반화 : is-a, 상위 클래스 특성 하위 클래스가 상속
      - 특수화 : is-a, 상위 클래스 특성 상속 받으면서 하위클래스에서 나름 수정, 고유한 특성



- 객체 지향 설계 원칙(SOLID)
  - 단일 책임의 원칙(Single Responsibility Principle)
    - 하나의 클래스는 하나의 목적만 가짐, 하나의 책임 수행
  - 개방 폐쇄 원칙(Open Close Principle)
    - 확장에는 열려있고 변경에는 닫혀 있어야 함
  - 리스코프 치환 원칙(Liskov Substitution Principle)
    - 하위 클래스(서브타입)는 어디서나 자신의 상위 타입(기반 타입)으로 교체 가능
  - 인터페이스 분리 원칙(Interface Segregation Principle)
    - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함
  - 의존성 역전의 원칙(Dependency Inversion Principle)
    - 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만듦(객체를 직접 다루지 않음)



- 객체 지향 방법론 종류
  - OOSE(Object Oriented Software Engineering) 
    - 야곱슨(Jacobson)
    - 유스케이스에 의한 접근 방법
    - 분석, 설계, 구현 단계
    - 기능적 요구사항 중심
  - OMT(Object Modeling Technology)
    - 럼바우(Rumbaugh)
    - 그래픽 표기법 이용 모델링
    - 분석 절차[객동기]
      - 객체 모델링(Object Modeling)
        - 객체 간 관계 정의
        - 객체 다이어그램 활용
      - 동적 모델링(Dynamic Modeling)
        - 객체들 사이 제어흐름, 동작 순서 등 동적 행위 표현
        - 상태 다이어그램 활용
      - 기능 모델링(Function Modeling)
        - 프로세스들 자료 흐름 중심 처리과정 표현
        - 자료 흐름도(DFD) 활용
  - OOD(Object Oriented Design)
    - 부치(Booch)
    - 설계 문서화 강조 다이어그램 중심 개발
    - 분석과 설계 분리 불가능
  - 코드-요든(Coad-Yourdon)
    - E-R 다이어그램 사용
    - 객체의 행위 모델링
    - 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성
  - 워프-브록(Wirfs-Brock)
    - 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행



- 디자인 패터
  - 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
  - 개발의 효율성 유지보수성, 운용성 등의 품질이 높아지며, 프로그램 최적화에 도움



- 디자인 패턴 구성요소[패문솔 사결샘]
  - 패턴의 이름 : 이름과 패턴 유형
  - 문제 및 배경 : 사용되는 분야, 배경, 해결하는 문제
  - 솔루션 : 요소들, 관계, 협동 과정
  - 사례 : 적용 사례
  - 결과 : 얻게되는 이점이나 영향
  - 샘플 코드 : 패턴이 적용된 원시 코드


- 디자인 패턴 유형[생구행]
  - 생성 패턴(Creational)
    - 객체 인스턴스 생성에 관여
    - 클래스 정의와 객체 생성 방식 구조화
    - 캡슐화 수행
  - 구조 패턴(Structural)
    - 더 큰 구조 형성 목적으로 클래스나 객체의 조합 다룸
  - 행동 패턴(Behavioral)
    - 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다룸



- 생성 패턴[생 빌 프로 패앱싱]
  - Builder
    - 복잡한 인스턴스를 조립하여 만드는 구조
    - 생성 방법과 구현 방법 분리
    - 동일한 생성 절차 서로 다른 표현 결과
  - Prototype
    - 일반적인 원형 만들어 두고 복사한 후 필요한 부분만 수정
    - 객체 생성 시 갖추어야 할 기본 형태가 있을 때 사용
    - 기존 객체를 복제함으로써 객체 생성
  - Factory Method
    - 상위 클래스에서 객체를 생성하는 인터페이스 정의
    - 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - 생성할 객체의 클래스를 국한하지 않고 객체를 생성
  - Abstract Factory
    - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스 제공
    - 동일한 주제의 다른 팩토리 묶음
  - Singleton
    - 전역 변수를 사용하지 않고 객체를 하나만 생성
    - 생성된 객체를 어디에서든지 참조
    - 한 클래스에 한 객체만 존재하도록 제한


- 구조 패턴[구 브데 퍼플 프록 컴어]
  - Bridge
    - 기능 클래스 계층, 구현 클래스 계층 연결
    - 구현부에서 추상 계층 분리
    - 추상화 부분 실제 구현 부분 독립적으로 확장
    - 추상화된 부분까지 변경해야 하는 경우 활용
  - Decorator
    - 기존 구현되어 있는 클래스에 필요한 기능 추가해 나가는 패턴
    - 기능 확 장 필요할 때 객체 간 결합을 통해 유동적 확장, 상속의 대안
    - 객체의 결합을 통해 기능을 동적으로 유연하게 확장
  - Facade
    - 복잡한 시스템에 단순한 인터페이스 제공
    - 사용자와 시스템 간, 여타 시스템과의 결합도 낮춤
    - 시스템 구조에 대한 파악 쉽게 해줌
    - 사용자 측면에서 단순한 인터페이스 제공을 통해 접근성 높임
    - 통합된 인터페이스 제공
  - Flyweight
    - 다수 객체 생성 될 경우 모두가 갖는 본질적 요소를 클래스 화하여 공유
    - 메모리 절약, '클래스의 경량화' 목적
    - 여러 개의 '가상 인스턴스' 제공 메모리 절감
  - Proxy
    - 실체 객체에 대한 대리 객체
    - 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만듦
    - 특정 객체로의 접근 제어 용도
  - Composite
    - 객체들의 관계를 트리 구조로 구성
    - 부분-전체 계층 표현
    - 단일 객체 복합 객체 모두 동일하게 취급
  - Adapter
    - 기존에 생성된 클래스를 재사용 할 수 있또록 중간에서 맞춰주는 역할의 인터페이스 생성
    - 상속을 이용하는 클래스 패턴, 위임을 이용하는 인스턴스 패턴 두가지 형태

  
- 행위패턴[행 미인이 템옵스테 비코스메체]
  - Mediator
    - 객체의 수가 많아져 서로 간 통신 복잡해지면서 느슨한 결합의 특성을 해치는 것 방지
    - 중간에서 이를 통제하고 지시할 수 있는 역할을 하는 중재자
    - 중재자에게 모든 것을 요구하여 통신의 빈도수 줄임
    - 상호 작용의 유연한 변경 지원
  - Interpreter
    - 언어의 다양한 해석
    - 구체적 구문을 나누고 분리된 구문의 해석을 맡는 클래스 각각 작성
    - 여러 형태 언어 구문 해석
    - 문법 자체를 캡슐화
  - Iterator
    - 컬렉션 구현 방법 노출시키지 않으면서 집합체 안에 들어있는 모든 항목 반복자를 사용해 접근
    - 내부구조 노출 없이, 복잡 객체의 원소 순차적으로 접근 가능
  - Template Method
    - 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분 수행
  - Observer
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용 갱신
    - 일대 다 의존성
  - State
    - 객체 상태를 캡슐화하여 클래스화하여 참조하게 하는 방식
    - 상태에 따라 다르게 처리할 수 있도록 행위 내용 변경
  - Visitor
    - 각 클래스 데이터 구조로부터 처리 기능을 분리 별도의 클래스 만들어 두고
    - 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만듦
    - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원
  - Command
    - 실행될 기능 캡슐화
    - 주어진 여러 기능을 실행할 수 있는 재사용성 높은 클래스 설계
  - Strategy
    - 알고리즘 군 정의(추상 클래스)
    - 같은 알고리즘을 각각 하나의 클래스로 캡슐화
    - 필요할 때 서로 교환해서 사용
    - 행위 객체를 클래스로 캡슐화해 동적으로 행위 자유롭게 변환
  - Memento
    - 클래스 설계 관점에서 객체의 정보를 저장할 필요 있을 때 적용
    - Undo 기능 개발할 때 사용
  - Chain of Responsibility
    - 기능에 대한 처리 동적으로 연결, 경우에 따라 다르게 처리될 수 있도록 
    - 한 요청을 2개 이상의 객체에서 처리 



- 디자인 패턴 장점
  - 요구사항 변경에 따른 소스 코드 변경 최소화
  - 소프트웨어 코드의 품질 향상
  - 설계 변경 요청에 대한 유연한 대처 가능
  - 범용적인 코딩 스탕리 적용 가능
  - 개발자 간 원활한 의사소통 가능
  - 재사용을 통한 개발 시간 단축 가능
  - 소프트웨어 구조 파악 용이
  - 객체 지향 설계 및 구현 생산성 높이는 데 적합
  - 소프트웨어 품질 생산성 향상
  
- 디자인 패턴 단점
  - 객체 지향 설계/구현 위주로 사용
  - 초기 투자 비용의 부담



- 내 외부 인터페이스 요구사항의 분류
  - 기능적 요구사항
    - 기능적 속성
  - 비기능적 요구사항
    - 성능, 사용의 용이성, 신뢰도, 보안성, 운용상의 제약, 안전성 등 시스템 전반과 관련된 요구사항


- 요구공학
  - 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동
  - 초기 요구사항 관리로 개발 비용과 시간을 절약하고 효과적인 의사소통 수단 제공



- 요구사항의 분류
  - 기능적 요구사항
    - 시스템이 제공하는 기능, 서비스에 대한 요구사항
    - 시스템 반응, 시스템 동작
    - 기능성, 완전성, 일관성
  - 비기능적 요구사항
    - 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항
    - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질관련 요구사항, 제약사항



- 요구사항 개발 단계[도분명확]
  - 요구사항 도출
    - 소프트웨어가 해결해야 할 문제 이해
    - 고객 분석, 조직 환경 분석, 후보 요구사항 분류, 후보 요구사항 정제, 요구사항 소스 관리
  - 요구사항 분석
    - 도출된 요구사항에 대해 충돌, 중복, 누락 등의 분석
    - 완전성, 일관성 확보
    - 주요 활동 - 요구사항 정의, 후보 요구사항 모델링, 우선순위 부여, 릴리즈에 수행할 요구사항 선정, 요구사항 협의
    - 요구사항 분석 활동 - 비용과 일정에 대한 제약설정, 타당성 조사, 요구사항 정의 문서화
  - 요구사항 명세
    - 검토, 평가, 승인될 수 잇는 문서 작성
    - 요구사항 명세 기준 저의, 요구사항 명세서 작성, 요구사항 추적 관련 정보 저장
  - 요구사항 확인 및 검증
    - 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검



- 요구사항 명세 원리 및 검증 항목[명완검 일수 추개]
  - 명확성
    - 각각 하나의 의미만 부여
  - 완전성
    - 모든 시스템 요구사항이 포함되어야 함
  - 검증 가능성
    - 충족 여부와 달성 정도에 대한 확인 가능
  - 일관성
    - 내용 간 상호 모순 없어야 함
  - 수정 용이성
    - 요구사항 변경 시 쉽게 수정 가능
  - 추적 가능성
    - 각 요구사항 근거에 대한 추적과 상호참조 가능
  - 개발 후 이용성
    - 운영 및 유지보수에 효과적 이용 가능



- 요구사항 도출 단계의 주요 기법
  - 인터뷰 : 직접 대화
  - 브레인스토밍 : 말 꺼내기 쉬운 분위기, 회의 참석자 아이디 수용
  - 델파이기법 : 전문가 경험적 지식 통한 문제 해결, 미래예측
  - 롤 플레잉 : 장면 설정, 맡은 역 연기
  - 워크숍 : 단기간 집중적인 노력, 핵심 인물 참여 필요
  - 설문조사 : 설문지, 여론조사



- 요구사항 분석 단계 기법
  - 자료 흐름 지향 분석
    - DFD, DD 로부터 소프트웨어 구조 유도
  - 객체 지향 분석
    - 기능과 데이터 함께 분석, UML 표준화


- 요구사항 명세 기법
  - 비정형 명세 기법
    - 자연어 기반
    - 사용자와 개발자 이해 용이
    - 명확성 및 검증에 문제 발생 가능
    - FSM, Decision Table, ER 모델링, State Chart(SADT)
  - 정형 명세 기법
    - 수학적 원리와 표기법 이용
    - 표현이 간결, 명확성 및 검증 용이
    - 기법 이해 어려움
    - VDM, Z-스키마, Petri-Nets, CSP
  - 요구사항 명세 단계의 산출물 요구사항 명세서(Requirement Specification)



- 정형 기술 검토 기법(요구사항 확인 및 검증단계에서 수행)[동워인]
  - 동료 검토(Peer Review)
    - 2~3명이 진행하는 리뷰 형태
    - 명세서 작성자가 명세서 설명, 이해관계자들이 설명 들으면서 결함 발견
  - 워크 스루(Walk Through)
    - 오류 조기 검출 목적
    - 검토 자료 회의 전 배포 사전검토, 짧은 시간 동안 회의
  - 인스펙션(Inspection)
    - 저작자 외 다른 전문가 또는 팀이 검사하여 오류 찾아냄
    - 계획 -> 사전 교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속조치


- 정형 기술 검토(FTR)
  - 제품의 검토에만 집중
  - 의제 제한하여 진행
  - 논쟁과 반박 제한
  - 문제 영역 명확히 표현
  - 해결책이나 개선책 논하지 말라
  - 참가자 수 제한, 사전 준비 강요
  - 자원과 시간 일정 할당
  - 모든 검토자들을 위해 의미있는 훈련
  - 검토자들은 사전에 작성한 메모들 공유
  - 검토의 과정과 결과를 재검토


- 시스템 
  - 하나의 공통적인 목적을 수행하기 위해 조직화된 요소들의 집합체


- 시스템 구성요소[입출처제피]
  - 입력(Input)
  - 출력(Output)
  - 처리(Process)
  - 제어(Control)
  - 피드백(Feedback)


- 시스템 아키텍처
  - 시스템의 구조, 행위, 동작 원리를 설명하는 프레임 워크


- 시스템 아키텍처 기본 요구사항
  - 시스템 구성 및 동작 원리를 나타내고 있어야 함
  - 시스템 구성요소 설계 및 구현 지원하는 수준으로 자세히 기술
  - 구성요소 간 관계 및 시스템 외부 환경과의 관계 설명
  - 요구사항 및 시스템 전체 생명주기 고려
  - 시스템 전체에 대한 논리적 기능 체계, 시스템 실현하기 위한 구성방식, 시스템의 전체적인 최적화 목표


- 시스템 아키텍처 설계 원칙[대학 고운보]
  - 대규모 트랜잭션 처리 및 온라인 성능 보장
  - 시스템 아키텍처 확장성 보장
  - 서비스 고가용성 보장
  - 운영관리 효율성
  - 시스템 보안 강화


- 시스템 아키텍처 물리 설계
  - 1 티어
    - (비즈니스 로직 + 데이터)
    - 물리적 노드 수 최소 1개
    - 티어 간 네트워크 트래픽 없음
  - 2 티어
    - (UI + 비즈니스 로직) (데이터)
    - 물리적 노드 수 최소 2개 이상 필요
    - AP와 DB 서버 간 네트워크 트래픽 발생
  - 3 티어
    - (UI 로직) (비즈니스 로직) (데이터)
    - 물리적 노드 수 최소 3개 이상 필요
    - 티어 간 네트워크 트래픽 발생


- 인터페이스 시스템
  - 서로 다른 두 시스템, 장치, 소프트웨어를 서로 이어주는 접속 및 중계 시스템


- 인터페이스 시스템 구성[송수중]
  - 송신 시스템
    - 연계할 데이터를 여계 테이블 또는 파일 형태로 생성하여 송신
  - 수신 시스템
    - 수신 시스템에서 관리하는 데이터 형식에 맞게 변환하여 활용
  - 중계 서버
    - 송신 시스템과 수신 시스템 사이에서 데이터 송수신하고 연계 데이터의 송수신 현황 모니터링
    - 연계 데이터 보안 강화 및 다중 플랫폼 지원 가능



- 내 외부 송 수신 연계 방식
  - 직접 연계 방식
    - 중계 서버나 솔루션 사용하지 않고 송신 시스템과 수신 시스템 직접 인터페이스
  - 간접 연계 방식
    - 연계 솔루션에서 제공하는 송수신 엔진과 어댑터 활용하여 인터페이스


- 내 외부 송 수신 연계 기술[링커 에제 하소]
  - DB 링크
    - DB 링크 객체 이용
    - 수신 시스템에서 DB 링크 생성, 송신 시스템에서 해당 DB 링크 직접 참조
  - DB 연결
    - 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB 커넥션 풀 생성, 연계프로그램에서 해당 커넥션 풀 사용
  - API/Open API
    - 송신 시스템 DB 데이터 읽어 제공 하는 API 프로그램
  - JDBC
    - 수신 시스템의 프로그램에서 JDBC 드라이버 이용하영 송신 시스템 DB와 연결
  - 하이퍼 링크
    - 웹 애플리케이션에서 하이퍼 링크 이용
  - 소켓
    - 통신을 위한 소켓을 생성하여 포트 할 당하고 클라이언트 통신 요청시 연결

- 내 외부 송 수신 통신 유형
  - 실시간
    - 단방향
    - 양방향
    - 동기
    - 비동기
    - 지연처리
  - 배치
    - DB/File 거래


- 데이터 명세화
  - 테이블 정의서, 파일 레이아웃, 코드 정의서 등을 분석하여 필요한 데이터 명세 만듦


- 데이터 명세화 문서
  - 개체 정의서
  - 테이블 정의서
  - 코드 정의서



- 미들웨어
  - 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어
  - 서로 다른 프로토콜이나 시스템 운영체제, 데이터베이스와 애플리케이션 간 통신을 지원해주는 소프트웨어
  - 애플리케이션이 어떤 정보시스템 환경에서도 작동할 수 있도록 지원
  - 분산 시스템 관점에서 위치 투명성 제공, 여러 컴포넌트가 요구하는 재사용 가능한 서비스 구현 제공


- 미들웨어 솔루션 유형[디원메트레객와]
  - DB 미들웨어
    - 애플리케이션과 DB 간 통신 원활하게 하는 것 목적
  - 원격 프로시저 호출(RPC; Remote Procedure Call)
    - 원격 프로시저를 로컬 프로시저처럼 호출
  - 메시지 지향 미들웨어(MOM; Message-Oriented Middleware)
    - 메시지 기반의 비동기형 메시지 전달 방식
    - 서로 다른 이기종 분산 DB 시스템의 데이터 동기 위하여 사용
  - 트랜잭션 처리 모니터(TP; Transaction Processing)
    - 온라인 업무에서 트랜잭션 처리, 감시
    - 분산 환경의 핵심 기술인 분산 트랜잭션 처리하기 위한 미들웨어
  - 레거시웨어(Lagacyware)
    - 기존 앱이나 DB 기반에 새로운 업데이트 된 기능을 덧붙이고자 할 때 사용
  - 객체기반 미들웨어(ORB; Object Request Brokers)
    - 코바(CORBA) 표준 스펙 구현한 객체 지향 미들웨어
    - 컴퓨터 간 프로그램과 데이터의 교환 및 변환 편리하게 이루어 짐
  - WAS(Web Application Server)
    - 서버계층에서 애플리케이션이 동작할 수 있는 환경 제공
    - 트랜잭션 처리 관리, 이기종 시스템과의 연동 지원
    - HTTP 세션 처리를 위한 웹 서버 기능 뿐 아니라 민감한 업무까지 구현 가능







