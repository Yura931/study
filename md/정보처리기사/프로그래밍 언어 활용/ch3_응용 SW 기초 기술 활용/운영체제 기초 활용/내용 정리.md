- UNIX 쉘(Shell)
  - 명령어 해석기
  - 시스템과 사용자 간의 인터페이스를 담당
  - 여러 종류의 쉘이 있음
  > 프로세스, 기억장치, 입출력 관리는 커널이 담당
  

- 운영체제
  - 다중 사용자와 다중 응용 프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당
  - CPU, 메모리 공간, 기억장치, 입출력 장치 등의 자원을 관리
  - 입출력 장치와 사용자 프로그램을 제어
  - 운영체제의 종류로는 윈도즈, 리눅스/유닉스, 맥, 안드로이드가 있음


- 운영체제 기능에 따라 분류 시 제어 프로그램
  - 데이터 관리 프로그램
  - 작업 제어 프로그램
  - 감시 프로그램
  > - 처리 프로그램(Processing Program)
  >   - 언어 번역 프로그램
  >   - 서비스 프로그램
  >   - 문제 프로그램


- UNIX에서 새로운 프로세스를 생성하는 명령어
  - fork


- 운영체제 분석을 위해 리눅스에서 버전을 확인하고자 할 때 사용되는 명령어
  - uname

    
- 지역성(Locality)
  - 프로세서들은 기억장치 내의 정보를 균일하게 접근하는 것이 아니라, 어느 한 순간에 특정 부분을 집중적을 ㅗ참조
  - 시간 지역성의 예는 "순환, 부 프로그램, 스택" 등이 있음
  - 공간 지역성은 하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조되는 경향이 있음을 의미
  - 공간 지역성의 예는 "순차적 코드의 실행"이 있음


- 도착 시간 문제에 없는 경우 전부 0 
- 반환시간 = 종료 시간 - 도착시간
- 대기시간 = 반환시간 - 서비스시간


- 메모리 관리 기법 중 Worst Fit(최악) 방법을 사용할 경우 10K 크기의 프로그램 실행을 위해서 어느 부분에 할당
  - 8K FREE
  - 12K FREE
  - 10K IN USE
  - 20K IN USE
  - 16K FREE
  - -> 16K
  - 프로세스의 가용 공간 중 가증 큰 공간에 할당


- 기억 공간 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때 기억장치 배치 전략으로 "First Fit"을 사용하여 17K의 프로그램을 적재할 경우 내부 단편화의 크기
  - 6K
  - 프로세스가 적재될 수 있는 가용 공간 중 첫 번째 분할에 할당하는 방식
  - 17K 프로세스가 적재될 수 있는 가용 공간 중 첫 번째 분할은 23K, 17K를 적재하면 6K의 내부 단편화 발생


- 주기억장치 할당 기법 중 분산 할당 기법
  - 프로그램을 고정 된 크기의 일정한 블록으로 나누는 Paging 기법
  - 가변적인 크기의 블록으로 나누는 Segmentation 기법


- 페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상
  - 디스크 접근 횟수가 많아져서 입 출력 시간 늘어난다
  - 내부 단편화가 감소
  - 페이지 맵 테이블의 크기가 증가 매핑 속도 늦어짐
  - 더 많은 페이지 사상 테이블 공간이 필요
  - 특정한 참조 구역성만을 포함하기 때문에 기억 장치 효율이 좋음


- 페이지 교체(Page Replacement) 알고리즘
  - FIFO(First-In-First-Out)
    - 각 페이지가 주기억 장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래 있떤 페이지를 교체
  - OPT(Optimal Replacement)
    - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
    - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘
  - LRU(Least Recently Used)
    - 사용된 시간을 확인하여 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
    - 프로그램의 지역성의 원리에 따라 최근에 참조된 페이지는 앞으로도 참조될 가능성이 크고
    - 최근에 참조되지 않은 페이지는 앞으로도 참조되지 않을 가능성이 크다는 전제로 구현된 알고리즘


- RR(Round-Robin)
  - Time Sharing System을 위해 고안된 방식
  - 시간 할당이 작아지면 프로세스-문맥 교환이 자주 일어남
  - 시간 할당이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있음
  - 같은 크기의 CPU 시간을 할당(Time Quantum)하고, 
  - 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, 
  - CPU는 대기 중인 다음 프로세스로 넘어가는 방식으로 우선순위 처리


- 프로세스
  - 프로그램 카운터, 레지스터 같은 현재 사용되는 자원에 대한 정보(PCB)를 가짐
  - CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행 중인 프로그램을 의미


- 스케줄링 기법 SJF(Shortest Job), SRT(Shortest Remaining)
  - SJF는 비선점 기법 
  - SJF는 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 선점
  - SRT는 짧은 수행시간 프로세스를 우선 수행
  - SRT에서는 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 있음
  - SRT는 선점형 기법



- 구역성(Locality)
  - 프로세스가 실행되면서 하나의 페이지를 일정시간 동안 집중적으로 액세스 하는 현상
  > - Thrashing
  >   - 프로세스의 처리 시간보다 페이지 교체 시간이 더 많아지는 현상
  > - Working Set
  >   - 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합
  > - Prepaging
  >   - 사용될 페이지라고 예측되어지는 페이지를 미리 적재하는 것
  


- HRN(Highest Response Ratio Next) 방식으로 스케줄링
  - (5 + 20) / 20 = 1
  - (40 + 20) / 20 = 3
  - (15 + 45) / 45 = 1.5
  - (20 + 2) / 2 = 11
  - (대기시간 + 서비스시간) / 서비스시간


- HRN(Highest Response-ratio Next) 스케줄링 방식
  - 대기시간이 긴 프로세스일 경우 우선순위가 높아 짐
  - SJF 기법을 보완하기 위한 방식
  - 긴 작업과 짧은 작업 간의 지나친 불평등을 해소
  - 우선순위를 계산하여 그 수치가 가장 높은 것부터 순서대로 우선순위 부여



- Microsoft의 Windows 운영체제 특징
  - GUI 기반 운영체제
  - 트리 디렉터리 구조
  - 선점형 멀티테스킹 방식
  > - Windows 운영체제는 소스가 공개되지 않았음
  > - 소스가 공개된 개방형 운영체제로는 CentOS 존재
  
  
- Time Sharing System 시분할 시스템
  - 운영체제의 운용 기법 중 중앙 처리 장치의 시간을 각 사용자에게 균등하게 분할하여 사용하는 체제로서 모든 컴퓨터 사용자에게 똑같은 서비스를 제공하는 것을 목표로 삼음
  - 라운드 로빈 스케줄링 사용


- 다단계 피드백 큐 MLFQ(Multi Level Feedback Queue)
  - FIFO와 RR 스케줄링 방식을 혼합한 것으로 상위 단계에서 완료되지 못한 작업은 하위 단계로 전달되어 마지막 단계에서는 RR 방식을 사용
  - 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용



- 스케줄링의 목적
  - 모든 작업들에 대해 공평성을 유지
  - 단위 시간당 처리량을 최대화
  - 응답 시간을 빠르게
  - 운영체제의 오버헤드를 최소화


- PCB(Process Control Block) 갖고 있는 정보
  - 프로세스의 현재 상태
  - 프로세스 고유 식별자
  - 스케줄링 및 프로세스의 우선순위
  > - 프로세스 구성
  >   - PCB(Process Control Block)
  >     - PID 프로세스 식별자, 프로세스 상태, 프로그램 카운트, 레지스터 저장영역, 프로그램 스케줄링 정보, 계정 정보, 입출력 상태정보, 메모리 관리 정보



- 비선점(Non-Preemptive) 스케줄링
  - 우선순위(Priority)
  - FIFO(First In First Out)(=FCFS(First Come, First Served))
  - 기한부(Deadline)
  - HRN(Highest Response-ratio Next)
  - SJF
  

- SJF(Shortest-Job-First) 스케줄링
  - 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원을 점유
  - 준비 큐 작업 중 가장 짧은 작업부터 수행, 평균 대기시간이 최소가 됨
  - 기아 현상 발생 가능
  - 비선점 스케줄링
> 남은 처리시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점 -> SRT(Shorted Remaining Time First)


- Thrashing
  - 프로세스들 간의 메모리 경쟁으로 인하여 지나치게 페이지폴트가 발생하여 전체 시스템의 성능이 저하되는 현상
  - 오류율이 클수록 스레싱이 많이 발생한 것



- 프로세스 적재 정책
  - 반복, 스택, 부프로그램은 시간 지역성(Temporal Locality)과 관련
  - 공간 지역성(Spatial Locality)은 프로세스가 어떤 페이지를 참조했다면 이후 가상주소 공간상 그 페이지와 인접한 페이지들을 교환 할 가능성이 높음을 의미
  - 스레싱 현상을 방지
    - 각 프로세스가 필요로 하는 프레임을 제공할 수 있어야 하는 페이지 부재 빈도(PFF; Page-Fault Frequency) 기법
    - 프로세스가 많이 참조하는 페이지들의 집합을 주기억 장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법인 워킹 세트


- Working Set
  - 운영체제의 가상기억장치 관리에서 프로세스가 일정시간동안 자주 참조하는 페이지들의 집합을 의미하는 것
  - 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법
  > - 교착상태(Deadlock)
  >   - 다중프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태



- 프로세스 상태의 종류
  - 생성 create
  - 준비 ready
  - 실행 running
  - 대기 waiting
  - 완료/종료 complete exit



- 스레드
  - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율 향상
  - 스레드는 그들이 속한 프로세스의 자원과 메모리를 공유
  - 다중 프로세스 구조에서 각 스레드는 다른 프로세스에서 병렬로 실행 될 수 있음
  - 스레드는 동일 프로세스 환경에서 서로 다른 독립적이 다중 수행이 가능
  - 프로세스보다 가벼운, 독립적으로 수행되는 순차적인 제어의 흐름이며, 실행 단위
  - 프로세스에서 실행 제어만 분리한 실행 단위!
  - 한 개의 프로세스는 여러 개의 스레드를 가질 수 있음
  - 커널 스레드의 경우 운영체제에 의해 스레드를 운용
  - 사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용
  - 스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율 향상
 

- 운영체제에서 스레드
  - 다중 프로그래밍 시스템에서 CPU를 받아서 수행되는 프로그램 단위
  - 프로세스나 태스크보다 더 작은 단위
  - 한 태스크는 여러 개의 스레드로 나누어 수행 될 수 있음
  > 입 출력 장치가 아닌 CPU 자원 할당에 관계
  

- 프로세스
  - 프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 Dispatch라고 함
  - 프로세스 제어 블록(PCB; Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성
  - 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재한느 과정을 문맥 교환(Context Switching) 이라고 함
  - 프로세스 간 통신은 IPC(Pipe, Message, 공유메모리 등)를 사용
  - 문맥교환을 통해 프로세스 간 교환이 일어나기 때문에 시스템 부하가 큼


- 교착상태 발생의 필요 충분 조건
  - 상호배제(Mutual Exclusion)
    - 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없음
  - 점유와 대기(Hold and Wait)
    - 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태
  - 비선점(Non Preemption)
    - 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능
  - 환형 대기(Circular Wait)
    - 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성


- 교착상태의 해결방법 중 회피(Avoidance) 기법과 밀접 관계 
  - 은행원 알고리즘(Banker's Algorithm)
  - Wound-Wait
  - Wait-Die


- SJF(Shortest Job First)
  - 비선점 스케줄링
  - 우선순위가 높은 프로세스가 자원을 선점하면 그 프로세스가 종료할 때까지 자원을 독점
  - 가장 작은 서비스 시간을 갖는 프로세스가 작업을 종료할 때까지 자원을 점유


- 리눅스 Bash 쉘 에서 export
  - export가 매개변수 없이 쓰일 경우 현재 설정된 환경 변수들이 출력
  - 사용자가 생성하는 변수는 export 명령어로 표시하지 않는 한 현재 쉘에 국한된다
  - 변수를 export 시키면 전역(Global) 변수처럼 되어 끝까지 기억


- UNIX SHELL 환경 변수를 출력하는 명령어
  - printenv
  - env
  - setenv(csh와 관련된 쉘에서 쓰임)


- 운영체제 커널
  - 프로세스 생성, 종료
  - 기억장치 할당, 회수
  - 파일 시스템 관리
  - 주변장치 관리
  > 쉘은 운영체제의 가장 바깥 부분에 위치해서 사용자 명령에 대한 처리를 담당하는 역할을 하고, 인터페이스 기능을 수행
  


- 디스크 스케줄링 SSTF(Shortest Seek Time First) 사용
  - 현재위치에서 탐색거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스
  - 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드 이동


- 파일 디스크립터(File Descriptor)
  - 파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 있음
  - 보조기억장치에 저장되어 있다가 파일이 개방되면 주기억장치로 이동
  - 파일 제어 블록(File Control Block)이라고도 함
  - 파일 시스템에서 관리하기 때문에 사용자가 직접 참조할 수 없음
  - 파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가질 수 있음


- UNIX 시스템의 쉘
  - 사용자가 명령을 해석하고 커널로 전달하는 기능
  - 반복적인 명령을 프로그램으로 만드는 프로그래밍 기능을 제공
  - 초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공
  > 쉘 프로그램 실행을 위해 프로세스와 메모리 관리하는 것은 커널
  


- UNIX
  - 하나 이상의 작업에 대하여 백그라운드에서 수행이 가능
  - Multi-User(다중 사용자), Multi-Tasking(다중 작업) 지원
  - 트리 구조의 계층 파일 시스템을 갖음
  - 이식성이 높으며 장치 간의 호환성 높음
  - 대화식 운영체제 기능 제공


- 내부 단편화
  - 분할된 공간에 프로세스를 적재한 후 남은 공간
  - 빈 기억 공간에 크기가 20K, 16KB, 8KB, 40KB일 때 기억장치 배치 전략으로 Best Fit을 사용하여 17KB 프로그램 적재 시 내부단편화 크기는 3KB


- LRU(Least Recently Used)
  - 가장 오랫동안 사용되지 않은 페이지 선택 교체



- HRN(High Response Ratio Next ) 스케줄링
  - 최소 작업 우선(SJF) 기법의 약점을 보완한 비선점 스케줄링 기법
  - 대기 중인 프로세스 중 대기시간이 긴 프로세스일 경우 우선순위가 높아지게 하여 우선순위를 결정하는 비선점 스케줄링 기법
  - 우선순위 = (대기시간 + 서비스를 받을 시간) / 서비스를 받을 시간


- 사용자 수준에서 지원되는 스레드
  - 커널 모드로의 전환 없이 스레드 교환이 간으하므로 오버헤드가 줄어듦
  - 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 블록이 걸리면 나머지 모든 스레드 역시 블록
  > 커널 레벨 스레드는 커널이 각 스레드를 개별적으로 관리할 수 있음








  



