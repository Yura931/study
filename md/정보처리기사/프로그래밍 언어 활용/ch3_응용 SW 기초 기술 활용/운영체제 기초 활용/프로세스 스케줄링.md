# 프로세스(Process) 스케줄링

---

### 프로세스

<strong style="background: #FFD5D2; padding: 5px;">1. 프로세스의 개념</strong>
- CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 실행 중인 프로그램
- 작업(Job) 또는 태스크(Task)라고도 함

<strong style="background: #FFD5D2; padding: 5px;">2. 프로세스 상태[생준 실대완]</strong>
> 하나의 프로세스는 여러가지 이벤트에 의해 일련의 서로 구분되는 상태변화를 겪음

- **생성(Create) 상태**
  - 사용자에 의해 프로세스가 생성된 상태
- **준비(Ready) 상태**
  - CPU를 할당받을 수 있는 상태
  - 준비 리스트 : 각각 우선순위를 부여하여 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당 받음
- **실행(Running) 상태**
  - 프로세스가 CPU를 할당받아 동작 중인 상태
- **대기(Waiting) 상태**
  - 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리 완료까지 대기 리스트에서 기다리는 상태
  - 대기 리스트 : 우선순위 존재하지 않음
- **완료(Complete) 상태 / 종료(Terminated; Exit) 상태**
  - 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태


<strong style="background: #FFD5D2; padding: 5px;">3. 프로세스 상태 전이</strong>
> 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기까지 프로세스의 상태가 준비, 실행 및 대기 상태 등으로 변하는 활동

- **디스패치(Dispatch)**
  - 준비 상태에 있는 여러 프로세스(Ready List) 중 실행될 프로세스를 선정(Scheduling)하여 CPU를 할당(Dispatching) -> 문맥교환 발생
  - 프로세스는 준비 상태에서 실행 상태로 전이
- **할당 시간 초과(Timeout)**
  - CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케쥴러에 의해 PCB(프로세스 제어블록) 저장, CPU 반납 후 다시 준비 상태로 전이
  - 실행 상태에서 준비 상태로 전이
  - 타임 슬라이스(Time Slice) 만료, 선점(Preemption) 시 타임아웃 발생
- **입출력 발생(Block)**
  - 실행 상태 프로세스가 지정된 할당 시간을 초과하기 전 입출력이나 기타 사건이 발생(block)하면 CPU를 스스로 반납하고 입출력이 완료될 때까지 대기 상태로 전이
  - 실행 상태에서 대기 상태로 전이
  - 즉시 실행 불가능한 시스템 콜, I/O 작업 시작, 프로세스 간 통신 시 Block 발생
- **깨움(Wake-up)**
  - 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이
  - 대기 상태에서 준비 상태로 전이

<strong style="background: #FFD5D2; padding: 5px;">4. 프로세스 구성</strong>
> 구성 요소 : 사용자 작성 코드, 사용자 사용 데이터, 스택, 프로세스 제어 블록

- **사용자 작성 코드**
  - 사용자가 작성한 프로그램 코드
- **사용자 사용 데이터**
  - 사용자 작성 프로그램 코드에서 사용하는 데이터
- **스택(Stack)**
  - 함수 호출(Procedure Call) 및 인자 값 전송(Arguments Passing)에 사용
- **프로세스 제어 블록(PCB; Process Control Block)**
  - 운영체제가 프로세스 관리를 위해 필요한 자료를 담고 있는 자료 구조
  - PCB는 프로세스 생성 시 만들어지고, 메인 메모리에 유지되며, 운영체제에서 한 프로세스의 전체를 정의
  - **PCB 구성요소[프상카레 스계입메]**
    - PID(프로세스 식별자), 프로세스 상태, 프로그램 카운트, 레지스터 저장영역
    - 프로세서 스케줄링 정보, 계정 정보, 입출력 상태 정보, 메모리 관리 정보

<strong style="background: #FFD5D2; padding: 5px;">5. 스레드(Thread)</strong>

**1) 스레드 개념**
- 프로세스보다 가벼운, 독립적으로 수행되는 순차적인 제어의 흐름, 실행 단위
- 프로세스에서 실행 제어만 분리한 실행 단위로 한 개의 프로세스는 여러 개의 스레드를 가질 수 있음

**2) 스레드 종류**
> 생성 주체에 따라 커널 수준 스레드(Kernel Level Thread)와 사용자 수준 스레드(User Level Thread)로 구분

- **커널 수준 스레드**
  - 스레드를 생성하고 스케줄링하는 주체가 커널인 스레드
  - **장점**
    - 커널이 각 스레드를 개별적으로 관리
    - 다른 스레드가 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업 진행
    - 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능 제공
  - **단점**
    - 사용자 모드에서 커널 모드로의 전환이 빈번하게 이루어져 오버헤드가 많음
    - 사용자 스레드에 비해 생성 및 관리하는 것이 느림
- **사용자 수준 스레드**
  - 사용자 영역에서 라이브러리를 통해 구현되는 스레드
  - **장점**
    - 커널 모드로 전환하지 않기 때문에 인터럽트가 발생할 때 오버헤드 적음
    - 사용자 영역 스레드에서 행동하기 때문에 OS 스케줄러의 문맥 교환(Context Switch)이 없음
  - **단점**
    - 스케줄링 우선순위를 지원하지 않으므로 어떤 스레드가 먼저 동작할지 알 수 없음
    - 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 블록이 걸리면 나머지 모든 스레드 역시 블록 됨

- 사용자 레벨 스레드는 프로세스 1개당 커널 스레드 1개가 할당

### 프로세스 스케줄링
<strong style="background: #FFD5D2; padding: 5px;">1. 프로세스 스케줄링</strong>
- CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업
- 처리율과 CPU 이용률 증가
- 오버헤드 ,응답시간, 반환시간, 대기시간을 최소화 시키기 위한 기법
- 특정 프로세스가 적합하게 실행되도록 프로세스 스케줄링에 의해 프로세스 사이에서 CPU 교체가 일어남
- 스케줄러의 유형에는 장기, 중기, 단기 스케줄러가 있음

<strong style="background: #FFD5D2; padding: 5px;">2. 프로세스 스케줄링 주요 용어</strong>
- **서비스 시간**
  - 프로세스가 결과를 산출하기까지 소요되는 시간
- **응답 시간(Response Time)**
  - 프로세스들이 입력되어 서비스를 요청하고, 반응하기 시작할 때까지 소요되는 시간
- **반환 시간(Turnaround Time)**
  - 프로세스들이 입력되어 수행하고 결과를 산출하기까지 소요되는 시간
  - 반환시간 = 대기시간 + 수행시간
- **대기 시간**
  - 프로세스가 프로세서에 할당되기까지 큐에 대기하는 시간
  - 프로세스가 도착 즉시 프로세서에 할당되면 대기시간 '0'
- **종료 시간**
  - 요구되는 Processing time을 모두 수행하고 종료된 시간
- **시간 할당량(Time Quantum 또는 Time Slice)**
  - 한 프로세스가 프로세서를 독점하는 것을 방지하기 위해 서비스되는 시간 할당량
- **응답률**
  - (대기시간 + 서비스시간) / 서비스 시간
  - HRN(Highest Response ratio Next) 스케줄링에서 사용
  - HRN 스케줄에서 응답률이 높으면 우선순위가 높다고 판단

<strong style="background: #FFD5D2; padding: 5px;">3. 프로세스 스케줄링 유형</strong>
- **선점형 스케줄링(Preemptive Scheduling)**
  - 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식
  - **장점**
    - 비교적 빠른 응답
    - 대화식 시분할 시스템에 적합
  - **단점**
    - 높은 우선순위 프로세스들이 들어오는 경우 오버헤드 초래
  - **알고리즘**
    - SRT(Shortest Remaining Time First)
    - 다단계 큐(MLQ; Multi-Level Queue)
    - 다단계 피드백 큐(MLFQ; Multi-Level Feedback Queue)
    - 라운드 로빈(Round Robin)
  - **활용**
    - 실시간 응답환경
    - Deadline 응답환경
- **비선점형 스케줄링(Non Preemptive Scheduling)**
  - 한 프로세스가 CPU를 할당 받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능
  - **장점**
    - 응답시간 예상이 용이
    - 모든 프로세스에 대한 요구를 공정하게 처리
  - **단점**
    - 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기
  - **알고리즘**
    - 우선순위(Priority)
    - 기한부(Deadline)
    - HRN(High Response Ratio Next)
    - FCFS(First Come, First Served)
    - SJF(Shortest Job First)
  - **활동**
    - 처리시간 편차가 적은 특정 프로세스 환경


<strong style="background: #FFD5D2; padding: 5px;">4. 프로세스 스케줄링 알고리즘</strong>

**1) 선점형 스케줄링 알고리즘[SMMR]**

- **SRT(Shorted Remaining Time First)**
  - 가장 짧은 시간이 소요되는 프로세스를 먼저 수행
  - 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점
- **다단계 큐(MLQ; Multi Level Queue)**
  - 작업들을 여러 종류 그룹으로 분할
  - 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점 당함
  - 각 큐는 자신만의 독자적인 스케줄링을 가짐
  - 독립된 스케줄링 큐
- **다단계 피드백 큐(MLFQ; Multi Level Feedback Queue)**
  - 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여
  - FCFS(FIFO)와 라운드 로빈 스케줄링 기법을 혼합한 것
  - 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질수록 점점 낮은 우선순위 큐로 이동
  - 마지막 단계는 라운드 로빈 방식을 적용
  - 큐마다 다른 시간 할당
  - 마지막 단계는 라운드 로빈 방식
- **라운드 로빈(Round Robin)**
  - 프로세스는 같은 크기의 CPU 시간을 할당(시간 할당량)
  - 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고 CPU는 대기 중인 다음 프로세스로 넘어감
  - 균등한 CPU 점유시간
  - 시분할 시스템에서 사용


**2) 비선점형 스케줄링 알고리즘[우기 HFS]**

- **우선순위(Priority)**
  - 각 프로세스 별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당
  - 동일 순위는 FCFS
  - 주요/긴급 프로세스에 대한 우선처리
  - 설정, 자원 상황 등에 따른 우선순위 선정
- **기한부(Deadline)**
  - 작업들이 명시된 시간이나 기한 내에 완료되도록 계획
  - 요청에 명시된 시간 내 처리를 보장
- **FCFS(First Come, First Served)**
  - 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당
  - FIFO 알고리즘이라고도 함
  - 도착한 순서대로 처리
- **SJF(Shortest Job First)**
  - 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유
  - 준비 큐 작업 중 가장 짧은 작업부터 수행, 평균 대기시간 최소
  - CPU 요구시간이 긴 작업과 짧은 작업 간의 불평등 심함
  - CPU 요구시간이 긴 프로세스는 기아 현상(Starvation; 준비 큐에 있는 프로레스가 무한정 기다리는 현상; 해결하기 위해 오랫동안 기다린 프로세스에게 우선순위를 높여줌으로써 처리하는 기법인 에이징(Aging) 활용) 발생
  - 기아 현상 발생 가능성
- **HRN(Highest Response Ratio Next)**
  - 대기 중인 프로세스 중 대기시간이 긴 프로세스일 경우 우선순위가 높아지게 하여 우선순위를 결정
  - 서비스받을 시간과 서비스를 기다린 시간을 고려하여 가변적 우선순위를 결정
  - HRN 우선순위 계산식 = (대기시간 + 서비스시간) / 서비스 시간
  - 우선순위 계산식의 수치가 가장 높은 것부터 낮은순으로 우선수위를 부여
  - SJF의 약점인 기아 현상을 보완한 기법
  - 긴 작업과 짧은 작업 간의 지나친 불평등 해소
  - 기아 현상 최소화 기법


---

> 프로세스 스케줄링 알고리즘 계산방법[반종도 대반서]
>
> 
> 반환 시간 = 종료 시간 - 도착 시간  
> 대기 시간 = 반환시간 - 서비스 시간

- FIFO(FCFS) 스케줄링
- 대기 큐에 도착한 순서에 따라 CPU 할당

| 프로세스 | 도착시간 | 서비스 시간 |
|------|------|--------|
| P1   | 0    | 3      |
| P2   | 1    | 7      |
| P3   | 3    | 2      |
| P4   | 5    | 5      |

- P1 0시간에 먼저 도착해서 자원점유
- 3시간 까지 자원 점유
- 3시간에 P1 종료
- P1 반환시간 = 3 - 0 = 3
- P1 대기시간 = 3 - 3 = 0


- P2가 1시에 도착
- 7시간 자원 점유
- 10시간에 P2 종료
- P2 반환시간 = 10 - 1 = 9
- P2 대기시간 = 9 - 7 = 2


- P3가 3시 도착 
- 2시간 자원 점유
- 12시간에 P3 종료
- P3 반환시간 = 12 - 3 = 9
- P3 대기시간 = 9 - 2 = 7


- P4가 5시 도착
- 5시간 자원 점유
- 17시간에 P4 종료
- P4 반환시간 = 17 - 5 = 12
- P4 대기시간 = 12 - 5 = 7


평균 반환 시간 = (3 + 9 + 9 + 12) / 4 = 8.25  
평균 대기 시간 = (0 + 2 + 7 + 7) / 4 = 4


---

### 프로세스 관리 - 교착상태(Deadlock)
<strong style="background: #FFD5D2; padding: 5px;">1. 교착상태 개념</strong>
- 다중프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태

<strong style="background: #FFD5D2; padding: 5px;">2. 교착상태 발생 조건[상점비환]</strong>
> 상호배제, 점유와 대기, 비선점, 환형 대기

- **상호배제(Mutual Exclusive)**
  - 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태
- **점유와 대기(Hold & wait)**
  - 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태
- **비선점(Non Preemption)**
  - 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고
  - 오직 점유한 프로세스만이 해제 가능한 상태
- **환형 대기(Circular Wait)**
  - 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태

<strong style="background: #FFD5D2; padding: 5px;">3. 교착상태 해결방법[예회발복]</strong>
> 예방, 회피, 발견, 복구

- **예방(Prevention)**
  - 상호배제를 제외한 나머지 교착상태 발생 조건을 위배(부정)하는 방안
  - 점유 자원 해제 후 새 자원 요청
- **회피(Avoidance)**
  - 안전한 사태를 유지할 수 있는 요구만 수락(프로세스별 자원 최대요구량 확보)
  - 은행가 알고리즘, Wound-Wait, Wait-Die
- **발견(Detection)**
  - 시스템의 상태를 감시 알고리즘을 통해 교착 상태 검사
  - 자원할당 그래프, Wait for Graph
- **복구(Recovery)**
  - 교착상태가 없어질 때까지 프로세스를 순차적으로 Kill하여 제거
  - 희생자 선택
  - 기아 상태 발생
  - 프로세스 Kill, 자원선점

> - 은행가 알고리즘(Banker's Algorithm)
>   - 사용자 프로세스는 사전에 자기 작업에 필요한 자원의 수를 제시하고 
>   - 운영체제가 자원의 상태를 감시, 안정상태일 때만 자원을 할당하는 교착상태 회피기법


### 디스크 스케줄링

<strong style="background: #FFD5D2; padding: 5px;">1. 디스크 스케줄링 개념</strong>
- 사용할 데이터가 디스크상의 여러 곳에 저장되어 있을 경우
- 데이터를 액세스하기 위해 디스크 헤드를 움직이는 경로를 결정
- 디스크 스케줄링은 운영체제가 담당
- 디스크 스케줄링의 목적은 처리량 최대화, 응답시간 최소화

<strong style="background: #FFD5D2; padding: 5px;">2. 디스크 스케줄링 종류</strong>
> FCFS, SSTF, SCAN, C-SCAN, LOOK, N-step SCAN, SLTF

- **FCFS(First Come, First Served)(=First In First Out)**
  - 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스
- **SSTF(Shortest Seek Time First)**
  - 현재 위치에서 탐색거리(Seek Distance)가 가장 짧은 트랙에 대한 요청을 먼저 서비스
  - 일괄처리 시스템에 유용
  - 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동
- **SCAN**
  - 현재 헤드의 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스
  - 끝까지 이동한 후 역방향의 요청 사항을 서비스
- **C-SCAN(Circular SCAN)**
  - 항상 바깥쪽에서 안쪽으로 움직이며 가장 짧은 탐색 거리를 갖는 요청을 서비스
  - 안쪽 끝까지 이동했으면 다시 바깥쪽부터 탐색하는 방법으로 비교적 공평
- **LOOK(=엘리베이터 알고리즘)**
  - SCAN을 기초로 사용하는 기법으로 진행 방향으로 더 이상의 요청이 없으면 역방향으로 진행
  - SCAN은 이동 방향의 끝까지 간 후 방향을 바꾸지만, LOOK은 요청까지만 간 후 방향을 바꿈
- **N-STEP SCAN**
  - SCAN 기법을 기초로 하며 어떤 방향의 진행이 시작될 당시에 대기중이던 요청들만 서비스
  - 진행 도중 도착한 요청들은 한꺼번에 모아서 다음의 반대 진행 방향으로 진행할 때 서비스
- **SLTF(Shortest Latency Time First)**
  - 섹터 큐잉(Sector Queuing)이라고 하며, 회전지연시간 최적화를 위해 구현된 기법
  - 디스크 헤드가 특정 실린더에 도착하면 그 실린더 내의 여러 트랙에 대한 요청들을 검사한 후, 회전지연시간이 가장 짧은 요청부터 서비스


