# 인덱스

---

- 테이블의 전체 데이터를 읽는 경우는 인덱스가 거의 불필요(이런 경우 인덱스를 사용하지 않는 FTS를 사용)
- 인덱스는 조회만을 위한 오브젝트이며, 삽입, 삭제, 갱신의 경우 오히려 부하를 가중
- B트리는 관계형 데이터베이스의 주요 인덱스 구조
- 인덱스가 존재하는 상황에서 데이터를 입력하면, 매번 인덱스 정렬이 일어나므로 데이터 마이그레이션 같이 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋음
- 인덱스를 생성할 때 정렬 순서를내림차순으로 하면 내림차순으로 정렬

## 트리 기반 인덱스
- DBMS에서 가장 일반적인 인덱스는 B-트리 인덱스

### B-TREE
- '='로 검색하는 일치(Exact Match)검색과 'BETWEEN', '>' 등과 같은 연산자로 검색하는 범위(Range) 검색 모두에 적합한 구조
- 브랜치 블록(Branch Block)과 리프 블록(Leaf Block)으로 구성
- 브랜치 블록 
  - 브랜치 블록 중에서 가장 상위에서 있는 블록을 루트 블록(Root Block)이라고 함
  - 분기를 목적으로 하는 블록
  - 다음 단계의 블록을 가리키는 포인터를 가지고 있음
- 리프 블록
  - 트리의 가장 아래 단계에 존재
  - 인덱스를 구성하는 칼럼의 데이터와 해당 데이터를 가지고 있는 행의 위치를 가리키는 레코드 식별자(RID, Record Identifier/Rowid)로 구성되어 있음
  - 양방향 링크(Double Link)를 가지고 있고, 이것을 통해서 오름 차순과 내림 차순 검색을 쉽게 할 수 있음


## SQL Server의 클러스터형 인덱스

## 전체 테이블 스캔
- 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로서 추출하고 조건에 맞지 않으면 버리는 방식으로 검색

## 인덱스 스캔
- 인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 액세스 기법
- 인덱스는 인덱스 구성 칼럼의 순서로 정렬되어 있음
- 인덱스의 구성 칼럼이 A+B라면 먼저 칼럼 A로 정렬되고 칼럼 A의 값이 동일할 경우에느 칼럼B로 정렬된다. 그리고 칼럼 B까지 모두 동일하면 레코드 식별자로 정렬된다.
- 인덱스 유일 스캔(Index Unique Scan)
  - 유일 인덱스를 사용하여 단 하나의 데이터를 추출하는 방식
  - 중복을 허락하지 않는 인덱스
  - 구성 칼럼에 모두 '='로 값이 주어지면 결과는 최대 1건이 됨
  - 구성 칼럼에 대해 모두 '='로 값이 주어진 경우에만 가능한 인덱스 스캔 방식
- 인덱스 범위 스캔(Index Range Scan)
  - 인덱스를 이용하여 한 건 이상의 데이터를 추출하는 방식
  - 유일 인덱스의 구성 칼럼 모두에 대해 '='로 값이 주어지지 않은 경우와 비유일 인덱스를 이용하는 모든 액세스 방식은 인덱스 범위 스캔 방식으로 데이터를 액세스 하는 것
- 인덱스 역순 범위 스캔(Index Range Scan Descending)
  - 인덱스의 리프 블록의 양방향 링크를 이용하여 내림 차순으로 데이터를 읽는 방식
  - 이 방식을 이용하여 최대값을 쉽게 찾을 수 있음



> - 옵티마이저는 인덱스가 존재하더라도 전체 테이블 스캔 방식을 취사 선택할 수 있음
> - 인덱스 스캔은 인덱스에 존재하는 레코드 식별자를 이용해서 검색하는 데이터의 정확한 위치를 알고 데이터를 읽음 -> 일부 데이터 찾을 때 좋음
> - 불필요하게 다른 블록을 더 읽을 필요 없음 -> 따라서 한 번의 I/O 요청에 한 블록씩 데이터를 읽음
> - 전체 테이블 스캔은 데이터를 읽을 때 한번의 I/O 요청으로 여러 블록을 한꺼번에 읽음 -> 테이블의 모든 데이터, 대부분의 데이터를 찾을 때 좋음
