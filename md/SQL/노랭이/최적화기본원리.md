### 146 - Join 기법에 대한 설명 
#### 정답 `1`
- NL Join은 선택도가 낮은(결과 행의 수가 적은)테이블이 선행 테이블로 선택되는 것이 일반적으로 유리하다.
#### 해설
- Sort Merge Join은 동등 Join(Equi Join), 비 동등 Join(Not Equi Join) 모두 사용 가능
- Hash Join은 행의 수가 작은 테이블을 선행 테이블로 선택하는 것이 유리
- Hash Join은 Sort Merge Join보다 일반적으로 더 우수한 성능을 보이지만, Join 대상 테이블이 Join Key 컬럼으로 정렬되어 있을 때는 Sort Merge Join이 더 우수한 성능을 낼 수도 있다.

### 145 - 해싱기법을 사용하여 조인하는 해시조인, 해시조인이 더 효과적일 수 있는 조건에대한 설명
#### 정답 `4`
- 조인 컬럼에 적당한 인덱스가 업서서 자연조인(Natural Join)이 비효율 적일 때
- 자연조인시 드라이빙(driving, outer table)집합 쪽에서 조인 액세스 량이 많아 Random 액세스 부하가 심할 때
- 소트 머지 조인(Sort Merge Join)을 하기에는 두 테이블이 너무 커서 소트 부하가 심할 때
#### 해설
- 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 조인할 때는 NL 조인이 적합하다.

#### 핵심정리
> - Hash Join은 조인 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 조인 기법이다.
> - Hash Join은 해쉬 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인 즉, 동등 조인에서만 사용할 수 있다.

### 144 - Sort Merge Join에 대한 설명
#### 정답 `4`
- 조인 칼럼에 적당한 인덱스가 없어서 NL 조인(Nested Loops)가 비효율적일 때 사용할 수 있다.
- Driving Table의 개념이 중요하지 않은 조인 방식이다.
- 조인 조건의 인덱스의 유무에 영향받지 않는다.
#### 해설
- EQUI(=), Non- EQUI JOIN 다 사용 가능

#### 핵심정리
> - Sort Merge Join은 조인 칼럼을 기준으로 데이터를 정렬하여 조인을 수행
> - 주로 스캔 방식으로 데이터를 읽음
> - 랜덤 액세스로 NL Join에서 부담이 되던 넓은 범위의 데이터를 처리할 때 이용되던 조인 기법
> - 정렬할 데이터가 많아 메모리에서 모든 정렬 작업을 수행하기 어려운 경우에는 임시 영역(디스크)을 사용하기 때문에 성능이 떨어질 수 있음

### 143 - SQL에서 나타날 수 있는 Join 기법
```sql
[DEPT 테이블 INDEX 정보]
PK_DEPT : DEPTNO
[EMP 테이블 INDEx 정보]
PK_EMP : EMPNO
IDX_EMP_01 : DEPTNO
    
[SQL]
SELECT *
FROM DEPT D 
WHERE D.DEPTNO = 'A001'
AND EXISTS (SELECT 'X' FROM EMP E WHRER D.DEPTNO = E.DEPTNO)
```
### 정답 `4`
- NESTED LOOP SEMI JOIN
### 해설
- EXISTS 절은 실행계획상에 주로 SEMI JOIN으로 나타난다.
- NESTED LOOP, HASH, SORT MERGE의 SEMI JOIN이 모두 나타날 수 있다.

### 142 - Nested Loop Join에 대한 설명
### 정답 `3`
- 조인 컬럼에 적당한 인덱스가 있어서 자연조인이 효율적일 때 유용
- Driving Table(선행 테이블)의 조인 데이터 양이 큰 영향을 주는 조인 방식
- 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 조회하는 경우 유용
### 해설
- 소트 머지 조인(Sort Merge Join)하기에 두 테이블이 너무 커서 소트 부하가 심할 때엔 Hash Join이 유용

### 141 - 옵티마이저와 실행계획에 대한 설명
#### 정답 `2`
- ORACLE의 규칙기반 옵티마이저에서 가장 우선 순위가 높은 규칙은 Single row by rowid 액세스 기법
- 비용기반 옵티마이저는 테이블, 인덱스 ,컬럼 등 객체의 통계정보를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있다.
- ORACLe의 실행계획에 나타나는 기본적인 Join 기법으로는 NL Join, Hash Join, Sort Merge Join 등이 있다.
#### 해설
- NL Join은 데이터를 집계하는 업무 보다는 OLTP의 목록 처리 업무에 많이 사용 됨
- DW 등의 데이터 집계 업무에서는 Hash Join, Sort Merge Join이 더 많이 사용 됨

### 140 - 인덱스에 대한 설명
#### 정답 `2`
- 인덱스는 데이터 조회 목적에는 효과적이지만, INSERT, UPDATE, DELETE 작업에는 오히려 많은 부하를 줄 수도 있다.
- SQL Server의 클러스터형 인덱스는 ORACLE의 IOT와 매우 유사하다.
- 인덱스는 INSERT와 DELETE 작업과는 다르게 UPDATE 작업에는 부하가 없을 수도 있다.
#### 해설
- 대량의 데이터를 조회하는 경우 인덱스를 이용한 조회보다는 테이블 전체 스캔 방식으로 조회 하는 것이 더 빠를 수 있다.(인덱스 스캔이 항상 전체 스캔보다 빠르다는 것을 보장할 수 없음)
- 인덱스를 구성하는 컬럼들의 순서는 데이터 조회 시 성능적인 관점에서 중요한 역할을 함
- 인덱스를 구성하는 컬럼 이외의 데이터가 UPDATE될 때는 인덱스로 인한 부하가 발생하지 않음

### 139 - 인덱스에 대한 설명
#### 정답 `4`
- 인덱스의 목적은 조회 성능을 최적화 하는 것
- INSERT, UPDATE, DELETE 등의 DML 처리 성능 저하시킬 수 있음
- B-트리 인덱스는 일치 및 범위 검색에 적절한 구조
#### 해설
- 인덱스 액세스는 테이블 전체 스캔보다 항상 유리하지 않음
- 인덱스를 스캔하여 테이블로 데이터를 찾아가는 방식이 랜덤 액세스
- 랜덤 액세스의 부하가 크기 때문에 많은 양의 데이터를 읽을 경우 인덱스 스캔보다 테이블 전체 스캔이 유리할 수 있음

### 138 - SQL에 대한 설명
#### 정답 `1, 3`

### 137 - 인덱스에 대한 설명
#### 정답 `3, 4`
- 규칙기반 옵티마이저는 적절한 인덱스가 존재하면 항상 인덱스를 사용하려고 함
- 인덱스 범위 스캔은 결과가 없으면 한 건도 반환하지 않을 수 있음
#### 해설
- 인덱스를 생성할 때 정렬 순서를 내림차순으로 하면 내림차순으로 정렬
- 비용기반 옵티마이저는 SQL을 수행하는데 있어 소용되는 비용을 계산하여 실행계획을 생성하므로 인덱스가 존재하더라도 전체 테이블 스캔이 유리하다고 판단할 수 도 있음

### 136 - INDEX에 대한 설명, 인덱스 종류
#### 정답 `2`
- B-TREE 인덱스 : 브랜치 블록과 리프 블록으로 구성되며, 브랜치 블록은 분기를 목적으로 하고 리프블록은 인덱스를 구성하는 컬럼의 값으로 정렬된다. 일반적으로 OLTP 시스템 환경에서 가장 많이 사용
- CLUSTERED 인덱스 : 인덱스의 리프 페이지가 곧 데이터 페이지이며, 리프 페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장 됨
- BITMAP 인덱스 : 시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우이 DW 및 AD-HOC 질의 환경을 위해 설계되었으며, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조

### 135 - 인덱스에 대한 설명
#### 정답 `1, 3`
- 테이블의 전체 데이터를 읽는 경우는 인덱스가 거의 불필요
- B(Balance) 트리는 관계형 데이터베이스의 주요 인덱스 구조
#### 해설
- 테이블의 전체 데이터를 읽는 경우는 인덱스를 사용하지 않는 FTS를 사용
- 인덱스는 조회만을 위한 오브젝트이며, 삽입, 삭제, 갱신의 경우 오히려 부하를 가중
- 인덱스가 존재하는 상황에서 데이터를 입력하면 매번 인덱스 정렬이 일어나므로 데이터 마이그레이션 같이 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후 인덱스를 다시 생성하는 것이 좋음

### 134 - 인덱스에 대한 설명
#### 정답 `2`
- 기본 인덱스에 널 값(Null Value)들이 나타날 수 없음
#### 해설
- 기본 인덱스(Primary Key)는 UNIQUE & NOT NULL의 제약조건
- 보조 인덱스는 UNIQUE 인덱스가 아니라면 중복 데이터의 입력 가능하며, 자주 변경되는 속성을 인덱스로 선정할 경우 UPDATE, DELETE 성능에 좋지 않은 영향을 미치므로 인덱스 후보로 적절하지 않음

### 133 - 옵티마이저와 실행계획에 대한 설명
#### 정답 `1, 4`
- 규칙기반 옵티마이저에서 제일 높은 우선순위는 행에 대한 고유 주소를 사용하는 방법
- SQL 처리 흐름도는 인덱스 스캔 및 전체 테이블 스캔 등의 액세스 기법을 표현할 수 있음
#### 해설
- 규칙기반 옵티마이저에서 제일 낮은 운선순위는 전체 테이블 스캔이고, 제일 높은 우선순위는 ROWID를 활용하여 테이블을 액세스 하는 방법
- SQL 처리 흐름도는 SQL문의 처리 절차를 시각적으로 표현한 것
- 인덱스 스캔 및 전체 테이블 스캔 등의 액세스 기법을 표현 할 수 있으며, 성능적인 측면도 표현할 수 있음
- 인덱스 범위 스캔은 결과 건수만큼 반환, 결과가 없으면 한 건도 반환하지 않을 수 있음

### 132 - SQL 처리 흐름도(Access Flow Diagram)에 대한 설명
#### 정답 `2, 4`
- 인덱스 스캔, 테이블 전체 스캔 등과 같은 액세스 기법이 표현
- SQL의 내부적인 처리 절차를 시각적으로 표현
#### 해설
- SQL 처리 흐름도는 SQL 실행계획을 시각화해서 표현한 것
- SQL 처리 흐름도만 보고 실행 시간을 알 수는 없음

### 131 - 실행계획에 대한 설명
#### 정답 `3`
- 실행계획은 SQL 처리를 위한 실행 절차와 방법을 표현한 것
- 실행계획은 조인 방법, 조인 순서, 액세스 기법 등이 표현
- CBO(Cost Based Optimizer)의 실행계획에는 단계별 예상 비용 및 건수 등이 표시 됨
#### 해설
- 실행방법이 달라진다고 해서 결과가 달라지지는 않음

### 130 - 실행계획 실행순서
#### 정답 `3, 4, 2`
#### 해설
- 실행계획을 읽는 순서는 위에서 아래로, 안에서 밖으로 읽는다.

### 129 - 실행계획을 통해서 알 수 있는 정보
#### 정답 `4`
- 액세스 기법
- 질의 처리 예상 비용(Cost)
- 조인 순서
#### 해설
- 실행계획은 예상 정보
- 실제 처리 건수는 트레이스 정보를 통해서 알 수 있음

### 128 - 비용기반 옵티마이저에 대한 설명
### 정답 `Cost Based Optimizer, 비용기반 옵티마이저, CBO`





